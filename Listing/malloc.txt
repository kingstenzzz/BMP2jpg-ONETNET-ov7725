; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\malloc.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\malloc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS -I..\..\User -I..\..\Libraries\FWlib\inc -I..\..\User\FATFS\option -I..\..\User\FATFS -I..\..\User\delay -I..\..\User\onenet\inc -I..\..\User\device\inc -I..\..\User\EDP -I..\..\User\onenet\inc -I..\..\User\hwtimer -I..\..\User\JPEGENCODE -I..\..\User\MALLOC -I..\..\User\dht11 -I..\..\User\flame -I..\..\User\warning -I..\..\User\beep -I..\..\User\adc -I..\..\User\IIC -I..\..\Freee-RTOS\include -I..\..\Freee-RTOS\portable\RVDS\ARM_CM3 -I..\..\User\IWDG -I..\..\User\light_moto -I..\..\User\M8266WIFI -I..\..\User\TIMER -I.\RTE\_____ -IF:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IF:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\..\output\malloc.crf ..\..\User\MALLOC\malloc.c]
                          THUMB

                          AREA ||i.mem_free||, CODE, READONLY, ALIGN=2

                  mem_free PROC
;;;98     //返回值:0,释放成功;1,释放失败;  
;;;99     u8 mem_free(u8 memx,u32 offset)  
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;100    {  
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;101        int i;  
;;;102        if(!mallco_dev.memrdy[memx])//未初始化,先执行初始化
000008  4815              LDR      r0,|L1.96|
00000a  5d00              LDRB     r0,[r0,r4]
00000c  b938              CBNZ     r0,|L1.30|
;;;103    	{
;;;104    		mallco_dev.init(memx);    
00000e  4814              LDR      r0,|L1.96|
000010  3818              SUBS     r0,r0,#0x18
000012  6801              LDR      r1,[r0,#0]  ; mallco_dev
000014  4620              MOV      r0,r4
000016  4788              BLX      r1
;;;105            return 1;//未初始化  
000018  2001              MOVS     r0,#1
                  |L1.26|
;;;106        }  
;;;107        if(offset<memsize[memx])//偏移在内存池内. 
;;;108        {  
;;;109            int index=offset/memblksize[memx];			//偏移所在内存块号码  
;;;110            int nmemb=mallco_dev.memmap[memx][index];	//内存块数量
;;;111            for(i=0;i<nmemb;i++)  						//内存块清零
;;;112            {  
;;;113                mallco_dev.memmap[memx][index+i]=0;  
;;;114            }  
;;;115            return 0;  
;;;116        }else return 2;//偏移超区了.  
;;;117    }  
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L1.30|
00001e  4811              LDR      r0,|L1.100|
000020  f8500024          LDR      r0,[r0,r4,LSL #2]     ;107
000024  42b0              CMP      r0,r6                 ;107
000026  d919              BLS      |L1.92|
000028  480f              LDR      r0,|L1.104|
00002a  f8500024          LDR      r0,[r0,r4,LSL #2]     ;109
00002e  fbb6f1f0          UDIV     r1,r6,r0              ;109
000032  480b              LDR      r0,|L1.96|
000034  3808              SUBS     r0,r0,#8              ;110
000036  f8500024          LDR      r0,[r0,r4,LSL #2]     ;110
00003a  f8302011          LDRH     r2,[r0,r1,LSL #1]     ;110
00003e  2500              MOVS     r5,#0                 ;111
000040  e008              B        |L1.84|
                  |L1.66|
000042  2300              MOVS     r3,#0                 ;113
000044  4806              LDR      r0,|L1.96|
000046  3808              SUBS     r0,r0,#8              ;113
000048  f8500024          LDR      r0,[r0,r4,LSL #2]     ;113
00004c  194f              ADDS     r7,r1,r5              ;113
00004e  f8203017          STRH     r3,[r0,r7,LSL #1]     ;113
000052  1c6d              ADDS     r5,r5,#1              ;111
                  |L1.84|
000054  4295              CMP      r5,r2                 ;111
000056  dbf4              BLT      |L1.66|
000058  2000              MOVS     r0,#0                 ;115
00005a  e7de              B        |L1.26|
                  |L1.92|
00005c  2002              MOVS     r0,#2                 ;116
00005e  e7dc              B        |L1.26|
;;;118    //释放内存(外部调用) 
                          ENDP

                  |L1.96|
                          DCD      mallco_dev+0x18
                  |L1.100|
                          DCD      memsize
                  |L1.104|
                          DCD      memblksize

                          AREA ||i.mem_init||, CODE, READONLY, ALIGN=2

                  mem_init PROC
;;;45     //memx:所属内存块
;;;46     void mem_init(u8 memx)  
000000  b510              PUSH     {r4,lr}
;;;47     {  
000002  4604              MOV      r4,r0
;;;48        mymemset(mallco_dev.memmap[memx], 0,memtblsize[memx]);//内存状态表数据清零  
000004  490b              LDR      r1,|L2.52|
000006  f8512024          LDR      r2,[r1,r4,LSL #2]
00000a  490b              LDR      r1,|L2.56|
00000c  f8510024          LDR      r0,[r1,r4,LSL #2]
000010  2100              MOVS     r1,#0
000012  f7fffffe          BL       mymemset
;;;49     	mymemset(mallco_dev.membase[memx], 0,memsize[memx]);	//内存池所有数据清零  
000016  4909              LDR      r1,|L2.60|
000018  f8512024          LDR      r2,[r1,r4,LSL #2]
00001c  4906              LDR      r1,|L2.56|
00001e  3908              SUBS     r1,r1,#8
000020  f8510024          LDR      r0,[r1,r4,LSL #2]
000024  2100              MOVS     r1,#0
000026  f7fffffe          BL       mymemset
;;;50     	mallco_dev.memrdy[memx]=1;								//内存管理初始化OK  
00002a  2101              MOVS     r1,#1
00002c  4802              LDR      r0,|L2.56|
00002e  3008              ADDS     r0,r0,#8
000030  5501              STRB     r1,[r0,r4]
;;;51     }  
000032  bd10              POP      {r4,pc}
;;;52     //获取内存使用率
                          ENDP

                  |L2.52|
                          DCD      memtblsize
                  |L2.56|
                          DCD      mallco_dev+0x10
                  |L2.60|
                          DCD      memsize

                          AREA ||i.mem_malloc||, CODE, READONLY, ALIGN=2

                  mem_malloc PROC
;;;68     //返回值:0XFFFFFFFF,代表错误;其他,内存偏移地址 
;;;69     u32 mem_malloc(u8 memx,u32 size)  
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;70     {  
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;71         signed long offset=0;  
000008  2500              MOVS     r5,#0
;;;72         u16 nmemb;	//需要的内存块数  
;;;73     	u16 cmemb=0;//连续空内存块数
00000a  46a9              MOV      r9,r5
;;;74         u32 i;  
;;;75         if(!mallco_dev.memrdy[memx])mallco_dev.init(memx);//未初始化,先执行初始化 
00000c  4825              LDR      r0,|L3.164|
00000e  5d00              LDRB     r0,[r0,r4]
000010  b920              CBNZ     r0,|L3.28|
000012  4824              LDR      r0,|L3.164|
000014  3818              SUBS     r0,r0,#0x18
000016  6801              LDR      r1,[r0,#0]  ; mallco_dev
000018  4620              MOV      r0,r4
00001a  4788              BLX      r1
                  |L3.28|
;;;76         if(size==0)return 0XFFFFFFFF;//不需要分配
00001c  b91f              CBNZ     r7,|L3.38|
00001e  f04f30ff          MOV      r0,#0xffffffff
                  |L3.34|
;;;77     
;;;78         nmemb=size/memblksize[memx];  	//获取需要分配的连续内存块数
;;;79         if(size%memblksize[memx])nmemb++;  
;;;80         for(offset=memtblsize[memx]-1;offset>=0;offset--)//搜索整个内存控制区  
;;;81         {     
;;;82     		if(!mallco_dev.memmap[memx][offset])cmemb++;//连续空内存块数增加
;;;83     		else cmemb=0;								//连续内存块清零
;;;84     		if(cmemb==nmemb)							//找到了连续nmemb个空内存块
;;;85     		{
;;;86                 for(i=0;i<nmemb;i++)  					//标注内存块非空 
;;;87                 {  
;;;88                     mallco_dev.memmap[memx][offset+i]=nmemb;  
;;;89                 }  
;;;90                 return (offset*memblksize[memx]);//返回偏移地址  
;;;91     		}
;;;92         }  
;;;93         return 0XFFFFFFFF;//未找到符合分配条件的内存块  
;;;94     }  
000022  e8bd87f0          POP      {r4-r10,pc}
                  |L3.38|
000026  4820              LDR      r0,|L3.168|
000028  f8500024          LDR      r0,[r0,r4,LSL #2]     ;78
00002c  fbb7f0f0          UDIV     r0,r7,r0              ;78
000030  b286              UXTH     r6,r0                 ;78
000032  481d              LDR      r0,|L3.168|
000034  f8500024          LDR      r0,[r0,r4,LSL #2]     ;79
000038  fbb7f1f0          UDIV     r1,r7,r0              ;79
00003c  fb007011          MLS      r0,r0,r1,r7           ;79
000040  b108              CBZ      r0,|L3.70|
000042  1c70              ADDS     r0,r6,#1              ;79
000044  b286              UXTH     r6,r0                 ;79
                  |L3.70|
000046  4819              LDR      r0,|L3.172|
000048  f8500024          LDR      r0,[r0,r4,LSL #2]     ;80
00004c  1e45              SUBS     r5,r0,#1              ;80
00004e  e024              B        |L3.154|
                  |L3.80|
000050  4814              LDR      r0,|L3.164|
000052  3808              SUBS     r0,r0,#8              ;82
000054  f8500024          LDR      r0,[r0,r4,LSL #2]     ;82
000058  f8300015          LDRH     r0,[r0,r5,LSL #1]     ;82
00005c  b920              CBNZ     r0,|L3.104|
00005e  f1090001          ADD      r0,r9,#1              ;82
000062  fa1ff980          UXTH     r9,r0                 ;82
000066  e001              B        |L3.108|
                  |L3.104|
000068  f04f0900          MOV      r9,#0                 ;83
                  |L3.108|
00006c  45b1              CMP      r9,r6                 ;84
00006e  d113              BNE      |L3.152|
000070  f04f0800          MOV      r8,#0                 ;86
000074  e009              B        |L3.138|
                  |L3.118|
000076  480b              LDR      r0,|L3.164|
000078  3808              SUBS     r0,r0,#8              ;88
00007a  f8500024          LDR      r0,[r0,r4,LSL #2]     ;88
00007e  eb050108          ADD      r1,r5,r8              ;88
000082  f8206011          STRH     r6,[r0,r1,LSL #1]     ;88
000086  f1080801          ADD      r8,r8,#1              ;86
                  |L3.138|
00008a  45b0              CMP      r8,r6                 ;86
00008c  d3f3              BCC      |L3.118|
00008e  4806              LDR      r0,|L3.168|
000090  f8500024          LDR      r0,[r0,r4,LSL #2]     ;90
000094  4368              MULS     r0,r5,r0              ;90
000096  e7c4              B        |L3.34|
                  |L3.152|
000098  1e6d              SUBS     r5,r5,#1              ;80
                  |L3.154|
00009a  2d00              CMP      r5,#0                 ;80
00009c  dad8              BGE      |L3.80|
00009e  f04f30ff          MOV      r0,#0xffffffff        ;93
0000a2  e7be              B        |L3.34|
;;;95     //释放内存(内部调用) 
                          ENDP

                  |L3.164|
                          DCD      mallco_dev+0x18
                  |L3.168|
                          DCD      memblksize
                  |L3.172|
                          DCD      memtblsize

                          AREA ||i.mem_perused||, CODE, READONLY, ALIGN=2

                  mem_perused PROC
;;;54     //返回值:使用率(0~100)
;;;55     u8 mem_perused(u8 memx)  
000000  b510              PUSH     {r4,lr}
;;;56     {  
000002  4601              MOV      r1,r0
;;;57         u32 used=0;  
000004  2300              MOVS     r3,#0
;;;58         u32 i;  
;;;59         for(i=0;i<memtblsize[memx];i++)  
000006  2200              MOVS     r2,#0
000008  e007              B        |L4.26|
                  |L4.10|
;;;60         {  
;;;61             if(mallco_dev.memmap[memx][i])used++; 
00000a  480b              LDR      r0,|L4.56|
00000c  f8500021          LDR      r0,[r0,r1,LSL #2]
000010  f8300012          LDRH     r0,[r0,r2,LSL #1]
000014  b100              CBZ      r0,|L4.24|
000016  1c5b              ADDS     r3,r3,#1
                  |L4.24|
000018  1c52              ADDS     r2,r2,#1              ;59
                  |L4.26|
00001a  4808              LDR      r0,|L4.60|
00001c  f8500021          LDR      r0,[r0,r1,LSL #2]     ;59
000020  4290              CMP      r0,r2                 ;59
000022  d8f2              BHI      |L4.10|
;;;62         } 
;;;63         return (used*100)/(memtblsize[memx]);  
000024  2064              MOVS     r0,#0x64
000026  4358              MULS     r0,r3,r0
000028  4c04              LDR      r4,|L4.60|
00002a  f8544021          LDR      r4,[r4,r1,LSL #2]
00002e  fbb0f0f4          UDIV     r0,r0,r4
000032  b2c0              UXTB     r0,r0
;;;64     }  
000034  bd10              POP      {r4,pc}
;;;65     //内存分配(内部调用)
                          ENDP

000036  0000              DCW      0x0000
                  |L4.56|
                          DCD      mallco_dev+0x10
                  |L4.60|
                          DCD      memtblsize

                          AREA ||i.myfree||, CODE, READONLY, ALIGN=2

                  myfree PROC
;;;120    //ptr:内存首地址 
;;;121    void myfree(u8 memx,void *ptr)  
000000  b570              PUSH     {r4-r6,lr}
;;;122    {  
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;123    	u32 offset;  
;;;124        if(ptr==NULL)return;//地址为0.  
000006  b904              CBNZ     r4,|L5.10|
                  |L5.8|
;;;125     	offset=(u32)ptr-(u32)mallco_dev.membase[memx];  
;;;126        mem_free(memx,offset);//释放内存     
;;;127    }  
000008  bd70              POP      {r4-r6,pc}
                  |L5.10|
00000a  4805              LDR      r0,|L5.32|
00000c  f8500025          LDR      r0,[r0,r5,LSL #2]     ;125
000010  1a26              SUBS     r6,r4,r0              ;125
000012  4631              MOV      r1,r6                 ;126
000014  4628              MOV      r0,r5                 ;126
000016  f7fffffe          BL       mem_free
00001a  bf00              NOP      
00001c  e7f4              B        |L5.8|
;;;128    //分配内存(外部调用)
                          ENDP

00001e  0000              DCW      0x0000
                  |L5.32|
                          DCD      mallco_dev+0x8

                          AREA ||i.mymalloc||, CODE, READONLY, ALIGN=2

                  mymalloc PROC
;;;131    //返回值:分配到的内存首地址.
;;;132    void *mymalloc(u8 memx,u32 size)  
000000  b570              PUSH     {r4-r6,lr}
;;;133    {  
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;134        u32 offset;  									      
;;;135    	offset=mem_malloc(memx,size);  	   				   
000006  4631              MOV      r1,r6
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       mem_malloc
00000e  4605              MOV      r5,r0
;;;136        if(offset==0XFFFFFFFF)return NULL;  
000010  1c68              ADDS     r0,r5,#1
000012  b908              CBNZ     r0,|L6.24|
000014  2000              MOVS     r0,#0
                  |L6.22|
;;;137        else return (void*)((u32)mallco_dev.membase[memx]+offset);  
;;;138    }  
000016  bd70              POP      {r4-r6,pc}
                  |L6.24|
000018  4802              LDR      r0,|L6.36|
00001a  f8500024          LDR      r0,[r0,r4,LSL #2]     ;137
00001e  4428              ADD      r0,r0,r5              ;137
000020  e7f9              B        |L6.22|
;;;139    //重新分配内存(外部调用)
                          ENDP

000022  0000              DCW      0x0000
                  |L6.36|
                          DCD      mallco_dev+0x8

                          AREA ||i.mymemcpy||, CODE, READONLY, ALIGN=1

                  mymemcpy PROC
;;;28     //n:需要复制的内存长度(字节为单位)
;;;29     void mymemcpy(void *des,void *src,u32 n)  
000000  b570              PUSH     {r4-r6,lr}
;;;30     {  
;;;31         u8 *xdes=des;
000002  4603              MOV      r3,r0
;;;32     	u8 *xsrc=src; 
000004  460c              MOV      r4,r1
;;;33         while(n--)*xdes++=*xsrc++;  
000006  e003              B        |L7.16|
                  |L7.8|
000008  f8145b01          LDRB     r5,[r4],#1
00000c  f8035b01          STRB     r5,[r3],#1
                  |L7.16|
000010  1e15              SUBS     r5,r2,#0
000012  f1a20201          SUB      r2,r2,#1
000016  d1f7              BNE      |L7.8|
;;;34     }  
000018  bd70              POP      {r4-r6,pc}
;;;35     //设置内存
                          ENDP


                          AREA ||i.mymemset||, CODE, READONLY, ALIGN=1

                  mymemset PROC
;;;38     //count:需要设置的内存大小(字节为单位)
;;;39     void mymemset(void *s,u8 c,u32 count)  
000000  b530              PUSH     {r4,r5,lr}
;;;40     {  
;;;41         u8 *xs = s;  
000002  4603              MOV      r3,r0
;;;42         while(count--)*xs++=c;  
000004  e001              B        |L8.10|
                  |L8.6|
000006  f8031b01          STRB     r1,[r3],#1
                  |L8.10|
00000a  1e14              SUBS     r4,r2,#0
00000c  f1a20201          SUB      r2,r2,#1
000010  d1f9              BNE      |L8.6|
;;;43     }	   
000012  bd30              POP      {r4,r5,pc}
;;;44     //内存管理初始化  
                          ENDP


                          AREA ||i.myrealloc||, CODE, READONLY, ALIGN=2

                  myrealloc PROC
;;;143    //返回值:新分配到的内存首地址.
;;;144    void *myrealloc(u8 memx,void *ptr,u32 size)  
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;145    {  
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;146        u32 offset;  
;;;147        offset=mem_malloc(memx,size);  
00000a  4631              MOV      r1,r6
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       mem_malloc
000012  4605              MOV      r5,r0
;;;148        if(offset==0XFFFFFFFF)return NULL;     
000014  1c68              ADDS     r0,r5,#1
000016  b910              CBNZ     r0,|L9.30|
000018  2000              MOVS     r0,#0
                  |L9.26|
;;;149        else  
;;;150        {  									   
;;;151    	    mymemcpy((void*)((u32)mallco_dev.membase[memx]+offset),ptr,size);	//拷贝旧内存内容到新内存   
;;;152            myfree(memx,ptr);  											  		//释放旧内存
;;;153            return (void*)((u32)mallco_dev.membase[memx]+offset);  				//返回新内存首地址
;;;154        }  
;;;155    } 
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L9.30|
00001e  4908              LDR      r1,|L9.64|
000020  f8511024          LDR      r1,[r1,r4,LSL #2]     ;151
000024  1948              ADDS     r0,r1,r5              ;151
000026  4632              MOV      r2,r6                 ;151
000028  4639              MOV      r1,r7                 ;151
00002a  f7fffffe          BL       mymemcpy
00002e  4639              MOV      r1,r7                 ;152
000030  4620              MOV      r0,r4                 ;152
000032  f7fffffe          BL       myfree
000036  4802              LDR      r0,|L9.64|
000038  f8500024          LDR      r0,[r0,r4,LSL #2]     ;153
00003c  4428              ADD      r0,r0,r5              ;153
00003e  e7ec              B        |L9.26|
;;;156    
                          ENDP

                  |L9.64|
                          DCD      mallco_dev+0x8

                          AREA ||.ARM.__AT_0x68000000||, DATA, NOINIT, ALIGN=2

                  mem2base
                          %        196608

                          AREA ||.ARM.__AT_0x68030000||, DATA, NOINIT, ALIGN=1

                  mem2mapbase
                          %        12288

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  mem1base
                          %        40960
                  mem1mapbase
                          %        2560

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  memtblsize
                          DCD      0x00000500
                          DCD      0x00001800
                  memblksize
                          DCD      0x00000020
                          DCD      0x00000020
                  memsize
                          DCD      0x0000a000
                          DCD      0x00030000

                          AREA ||.data||, DATA, ALIGN=2

                  mallco_dev
                          DCD      mem_init
                          DCD      mem_perused
                          DCD      mem1base
                          DCD      mem2base
                          DCD      mem1mapbase
                          DCD      mem2mapbase
000018  00000000          DCB      0x00,0x00,0x00,0x00
