; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\m8266wifi_ops.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\m8266wifi_ops.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS -I..\..\User -I..\..\Libraries\FWlib\inc -I..\..\User\FATFS\option -I..\..\User\FATFS -I..\..\User\delay -I..\..\User\onenet\inc -I..\..\User\device\inc -I..\..\User\EDP -I..\..\User\onenet\inc -I..\..\User\hwtimer -I..\..\User\JPEGENCODE -I..\..\User\MALLOC -I..\..\User\dht11 -I..\..\User\flame -I..\..\User\warning -I..\..\User\beep -I..\..\User\adc -I..\..\User\IIC -I..\..\Freee-RTOS\include -I..\..\Freee-RTOS\portable\RVDS\ARM_CM3 -I..\..\User\IWDG -I..\..\User\light_moto -I..\..\User\M8266WIFI -I..\..\User\TIMER -I.\RTE\_____ -IF:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IF:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\..\output\m8266wifi_ops.crf ..\..\User\M8266WIFI\M8266WIFI_ops.c]
                          THUMB

                          AREA ||i.M8266WIFI_Config_Connection_via_SPI||, CODE, READONLY, ALIGN=1

                  M8266WIFI_Config_Connection_via_SPI PROC
;;;441     *************************************************************************************/
;;;442    u8 M8266WIFI_Config_Connection_via_SPI(u8 tcp_udp, u16 local_port, char* remote_addr, u16 remote_port, u8 link_no)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;443    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8028          LDR      r8,[sp,#0x28]
;;;444    	u16 status=0;
000010  2000              MOVS     r0,#0
000012  9003              STR      r0,[sp,#0xc]
;;;445      //  u8 M8266WIFI_SPI_Setup_Connection(u8 tcp_udp, u16 local_port, char remote_addr, u16 remote_port, u8 link_no, u8 timeout_in_s, u16* status);
;;;446    	return M8266WIFI_SPI_Setup_Connection(tcp_udp, local_port, remote_addr, remote_port, link_no, 20, &status);
000014  a803              ADD      r0,sp,#0xc
000016  2114              MOVS     r1,#0x14
000018  463b              MOV      r3,r7
00001a  4632              MOV      r2,r6
00001c  e9cd8100          STRD     r8,r1,[sp,#0]
000020  9002              STR      r0,[sp,#8]
000022  4629              MOV      r1,r5
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       M8266WIFI_SPI_Setup_Connection
;;;447    }
00002a  b004              ADD      sp,sp,#0x10
00002c  e8bd81f0          POP      {r4-r8,pc}
;;;448    
                          ENDP


                          AREA ||i.M8266WIFI_Module_Hardware_Reset||, CODE, READONLY, ALIGN=1

                  M8266WIFI_Module_Hardware_Reset PROC
;;;42      ************************************************************************************************************************/
;;;43     void M8266WIFI_Module_Hardware_Reset(void) // total 800ms
000000  b510              PUSH     {r4,lr}
;;;44     {
;;;45     	 M8266HostIf_Set_SPI_nCS_Pin(0);   			// Module nCS==ESP8266 GPIO15 as well, Low during reset in order for a normal reset 
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       M8266HostIf_Set_SPI_nCS_Pin
;;;46     	 M8266WIFI_Module_delay_ms(1); 	    		// delay 1ms, adequate for nCS stable
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       M8266WIFI_Module_delay_ms
;;;47     	
;;;48     	 M8266HostIf_Set_nRESET_Pin(0);					// Pull low the nReset Pin to bring the module into reset state
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       M8266HostIf_Set_nRESET_Pin
;;;49     	 M8266WIFI_Module_delay_ms(5);      		// delay 1ms, adequate for nRESET stable.
000014  2005              MOVS     r0,#5
000016  f7fffffe          BL       M8266WIFI_Module_delay_ms
;;;50     																					// give more time especially for some board not good enough
;;;51     	
;;;52     	 M8266HostIf_Set_nRESET_Pin(1);					// Pull high again the nReset Pin to bring the module exiting reset state
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       M8266HostIf_Set_nRESET_Pin
;;;53     	 M8266WIFI_Module_delay_ms(300); 	  		// at least 18ms required for reset-out-boot sampling boottrap pin
000020  f44f7096          MOV      r0,#0x12c
000024  f7fffffe          BL       M8266WIFI_Module_delay_ms
;;;54     																					// Here, we use 300ms for adequate abundance, since some board GPIO,
;;;55     																					// needs more time for stable(especially for nRESET)
;;;56     																					// You may shorten the time or give more time here according your board v.s. effiency
;;;57      	 M8266HostIf_Set_SPI_nCS_Pin(1);
000028  2001              MOVS     r0,#1
00002a  f7fffffe          BL       M8266HostIf_Set_SPI_nCS_Pin
;;;58      //M8266WIFI_Module_delay_ms(1); 	    		// delay 1ms, adequate for nCS stable
;;;59     	
;;;60        M8266WIFI_Module_delay_ms(800-300-5-2); // Delay more than around 500ms for M8266WIFI module bootup and initialization 
00002e  f24010ed          MOV      r0,#0x1ed
000032  f7fffffe          BL       M8266WIFI_Module_delay_ms
;;;61     																					 // including bootup information print¡£ 
;;;62     }
000036  bd10              POP      {r4,pc}
;;;63     /***********************************************************************************
                          ENDP


                          AREA ||i.M8266WIFI_Module_Init_Via_SPI||, CODE, READONLY, ALIGN=2

                  M8266WIFI_Module_Init_Via_SPI PROC
;;;112     ***********************************************************************************/
;;;113     u8 M8266WIFI_Module_Init_Via_SPI(void)
000000  b510              PUSH     {r4,lr}
;;;114     {
000002  b094              SUB      sp,sp,#0x50
;;;115    	u32  	spi_clk = 40000000;
000004  4c36              LDR      r4,|L3.224|
;;;116    	u8   	sta_ap_mode = 0;
000006  2000              MOVS     r0,#0
000008  9013              STR      r0,[sp,#0x4c]
;;;117    	u8   	connection_status = 0xFF;
00000a  20ff              MOVS     r0,#0xff
00000c  9012              STR      r0,[sp,#0x48]
;;;118    	char 	sta_ip[15+1]={0};
00000e  2000              MOVS     r0,#0
000010  900e              STR      r0,[sp,#0x38]
000012  900f              STR      r0,[sp,#0x3c]
000014  9010              STR      r0,[sp,#0x40]
000016  9011              STR      r0,[sp,#0x44]
;;;119    	char 	ssid[32];
;;;120    	s8   	rssi;
;;;121    	u16  	status = 0;
000018  9004              STR      r0,[sp,#0x10]
;;;122    	
;;;123      //////////////////////////////////////////////////////////////////////////////////////////////////////
;;;124    	//To hardware reset the module (with nCS=0 during reset) and wait up the module bootup
;;;125    	M8266WIFI_Module_Hardware_Reset();
00001a  f7fffffe          BL       M8266WIFI_Module_Hardware_Reset
;;;126    	
;;;127    	
;;;128    	/////////////////////////////////////////////////////////////////////////////////////////////////////
;;;129      // Try SPI clock in a fast one as possible up to 40MHz (M8266WIFI could support only upto 40MHz SPI) 
;;;130    	/* Notes: 
;;;131    	     As per STM32, SPI1/4 Clock Divided from APB2 Clock, SPI1/4 CLOCK = APB2_CLOCK/SPI_BaudRatePrescaler
;;;132    	                SPI2/3 Clock Divided from APB1 Clock, SPI2/3 CLOCK = APB1_CLOCK/SPI_BaudRatePrescaler
;;;133    	         (1) For STM32F1, , please see system_stm32f10x.c, APB2_CLOCK = PCLK2 = HCLK = SYSCLK, APB1_CLOCK=PCLK1 = HCLK/4 = SYSCLK/2! please see system_stm32f10x.c, 
;;;134    	                                    SYSCLK  = 72MHz, so, APB2_CLOCK = 72MHz
;;;135    		       (2) For STM32F2, please see system_stm32f2xx.c, APB2_CLOCK = PCLK2 = HCLK/2 = SYSCLK/2, APB1_CLOCK=PCLK1 = HCLK/4 = SYSCLK/4! please see system_stm32f2xx.c, 
;;;136    	                 - STM32F207xx:     SYSCLK          = 120MHz, so, APB2_CLOCK = 60MHz, APB1_CLOCK = 30MHz 
;;;137    	         (3) For STM32F4, APB2_CLOCK = PCLK2 = HCLK/2 = SYSCLK/2, APB1_CLOCK=PCLK1 = HCLK/4 = SYSCLK/4! please see system_stm32f4xx.c, 
;;;138    	                          Meanwhile, the PCLK2 should <= 90MHz, and SPI_CLK should <= 45MHz
;;;139    								   - STM32F401xx:     SYSCLK          = 168MHz, so, APB2_CLOCK = 84MHz, APB1=42MHz
;;;140    	                 - STM32F40_41xxx:  SYSCLK          = 168MHz, so, APB2_CLOCK = 84MHz, APB1=42MHz
;;;141    	                 - STM32F427_437xx, STM32F429_439xx = 180MHz, so, APB2_CLOCK = 90MHz, APB1=45MHz
;;;142    	         (4) For STM32F7, please see sys.c, APB2_CLOCK = PCLK2 = HCLK/2 = SYSCLK/2
;;;143    	                          Meanwhile, the PCLK2 should <= 108MHz, and SPI_CLK should <=54MHz
;;;144    	                 - STM32F767xx:     SYSCLK          = 216MHz, so, APB2_CLOCK = 108MHz, APB2_CLOCK = 54MHz
;;;145    	         (5) For STM32L1, please see sys.c, APB1_CLK = APB2_CLOCK = HCLK = SYSCLK = 32MHz				 
;;;146    	         (6) For STM32L4, please see sys.c, APB1_CLK = APB2_CLOCK = HCLK = SYSCLK = 80MHz
;;;147    					 
;;;148    					 (6) For STM32H7, using reset default:
;;;149    									 SPI 1/2/3 kernel clock = pll1_q_ck = 200MHz
;;;150    									 SPI 4/5   kernel clock = APB clock = 100MHz
;;;151    
;;;152    		   For MCU_IS_NXP_LPC17XX
;;;153    	         (1) SPI Clock =PCLK_SPI/SPI_BaudRatePrescaler
;;;154    	         (2) PCLK_SPI  =  CPU_CLK = 96MHz, please see system_LPC17xx.c
;;;155    					 
;;;156    		   For MMCU_IS_NXP_MK27_28
;;;157    	         (1) SPI 0/1/2/3 SPI Clock = BUS_CLOCK= (75MHz)/SPI_BaudRateScaler(=2)/SPI_BaudRatePrecaler = 37.5MHz/SPI_BaudRatePrecaler
;;;158    					 (2) SPI 3       SPI Clock = SYS_CLOCK=(150MHz)/SPI_BaudRateScaler(=2)/SPI_BaudRatePrecaler = 75.0MHz/SPI_BaudRatePrecaler
;;;159    					 
;;;160    	     For MCU_IS_HT32F16XX
;;;161    	         (1) SPI Clock   =  APB_CLK_SPI / SPI_BaudRatePrescaler
;;;162    	         (2) APB_CLK_SPI =  SYS_CLK /2 = 144MHz /2 = 72MHz, please see system_ht32f165x.c
;;;163    */
;;;164    #if defined(MCU_IS_STM32) && !defined(MCU_IS_STM32H7XX)
;;;165    #ifndef SPI_BaudRatePrescaler_2
;;;166    #define SPI_BaudRatePrescaler_2 				((uint32_t)0x00000000U)
;;;167    #define SPI_BaudRatePrescaler_4         ((uint32_t)0x00000008U)
;;;168    #define SPI_BaudRatePrescaler_8         ((uint32_t)0x00000010U)
;;;169    #define SPI_BaudRatePrescaler_16        ((uint32_t)0x00000018U)
;;;170    #define SPI_BaudRatePrescaler_32        ((uint32_t)0x00000020U)
;;;171    #define SPI_BaudRatePrescaler_64        ((uint32_t)0x00000028U)
;;;172    #define SPI_BaudRatePrescaler_128       ((uint32_t)0x00000030U)
;;;173    #define SPI_BaudRatePrescaler_256       ((uint32_t)0x00000038U)
;;;174    #endif
;;;175    
;;;176    #elif defined(MCU_IS_STM32H7XX)
;;;177    #ifndef SPI_BAUDRATEPRESCALER_2
;;;178    #define SPI_BAUDRATEPRESCALER_2         (0x00000000U)
;;;179    #define SPI_BAUDRATEPRESCALER_4         (0x10000000U)
;;;180    #define SPI_BAUDRATEPRESCALER_8         (0x20000000U)
;;;181    #define SPI_BAUDRATEPRESCALER_16        (0x30000000U)
;;;182    #define SPI_BAUDRATEPRESCALER_32        (0x40000000U)
;;;183    #define SPI_BAUDRATEPRESCALER_64        (0x50000000U)
;;;184    #define SPI_BAUDRATEPRESCALER_128       (0x60000000U)
;;;185    #define SPI_BAUDRATEPRESCALER_256       (0x70000000U)
;;;186    #endif
;;;187    
;;;188    #elif defined(MCU_IS_NXP_LPC17XX)
;;;189    #ifndef SPI_BaudRatePrescaler_2
;;;190    #define SPI_BaudRatePrescaler_2         ((uint32_t)0x00000002U)
;;;191    #define SPI_BaudRatePrescaler_4         ((uint32_t)0x00000004U)
;;;192    #define SPI_BaudRatePrescaler_6         ((uint32_t)0x00000006U)
;;;193    #define SPI_BaudRatePrescaler_8         ((uint32_t)0x00000008U)
;;;194    #define SPI_BaudRatePrescaler_16        ((uint32_t)0x00000010U)
;;;195    #define SPI_BaudRatePrescaler_32        ((uint32_t)0x00000020U)
;;;196    #define SPI_BaudRatePrescaler_64        ((uint32_t)0x00000040U)
;;;197    #define SPI_BaudRatePrescaler_128       ((uint32_t)0x00000080U)
;;;198    #define SPI_BaudRatePrescaler_256       ((uint32_t)0x00000100U)
;;;199    #endif
;;;200    
;;;201    #elif defined (MCU_IS_NXP_MK27_28)
;;;202    #ifndef SPI_BaudRatePrescaler_2
;;;203    #define SPI_BaudRatePrescaler_2         ((uint32_t)0x00000000U)
;;;204    #define SPI_BaudRatePrescaler_4         ((uint32_t)0x00000001U)
;;;205    #define SPI_BaudRatePrescaler_6         ((uint32_t)0x00000002U)
;;;206    #define SPI_BaudRatePrescaler_8         ((uint32_t)0x00000003U)
;;;207    #define SPI_BaudRatePrescaler_16        ((uint32_t)0x00000004U)
;;;208    #define SPI_BaudRatePrescaler_32        ((uint32_t)0x00000005U)
;;;209    #define SPI_BaudRatePrescaler_64        ((uint32_t)0x00000006U)
;;;210    #define SPI_BaudRatePrescaler_128       ((uint32_t)0x00000007U)
;;;211    #define SPI_BaudRatePrescaler_256       ((uint32_t)0x00000008U)
;;;212    #endif
;;;213    #else
;;;214    #endif
;;;215    
;;;216    #if    defined(MCU_IS_STM32F1XX) || defined(MCU_IS_STM32F3XX) // F1 has SPI, SPI2 & SPI3
;;;217      #if (M8266WIFI_SPI_INTERFACE_NO == 1)
;;;218    		M8266HostIf_SPI_SetSpeed(SPI_BaudRatePrescaler_4);				// Setup SPI Clock. Here 72/4 = 18MHz for STM32F2xx SPI1 or SPI4, up to 18MHz, since SPI1/4 clock devided from faster APB2 clock
00001e  2008              MOVS     r0,#8
000020  f7fffffe          BL       M8266HostIf_SPI_SetSpeed
;;;219      #elif (M8266WIFI_SPI_INTERFACE_NO == 2) || (M8266WIFI_SPI_INTERFACE_NO == 3)
;;;220    		M8266HostIf_SPI_SetSpeed(SPI_BaudRatePrescaler_2);				// Setup SPI Clock. Here 36/2 = 18MHz for STM32F2xx SPI2 or SPI3, up to 18MHz, since SPI2/3 clock devided from lowver APB1 clock
;;;221    	#endif
;;;222     	  spi_clk =  18000000;
000024  4c2f              LDR      r4,|L3.228|
;;;223    		
;;;224    #elif  defined(MCU_IS_STM32F2XX)  // F2 has SPI1, SPI2 & SPI3
;;;225      #if (M8266WIFI_SPI_INTERFACE_NO == 1)
;;;226    		M8266HostIf_SPI_SetSpeed(SPI_BaudRatePrescaler_4);				// Setup SPI Clock. Here 60/4 = 15MHz for STM32F2xx SPI1 or SPI4, up to 30MHz, since SPI1/4 clock devided from faster APB2 clock
;;;227      #elif (M8266WIFI_SPI_INTERFACE_NO == 2) || (M8266WIFI_SPI_INTERFACE_NO == 3)
;;;228    		M8266HostIf_SPI_SetSpeed(SPI_BaudRatePrescaler_2);				// Setup SPI Clock. Here 30/2 = 15MHz for STM32F2xx SPI2 or SPI3, up to 15MHz, since SPI2/3 clock devided from lowver APB1 clock
;;;229    	#endif
;;;230     	  spi_clk =  15000000;
;;;231    
;;;232    #elif  defined(MCU_IS_STM32F4XX)  // F4 has SPI, SPI2 & SPI3, and possible SPI4
;;;233      #if (M8266WIFI_SPI_INTERFACE_NO == 1) || (M8266WIFI_SPI_INTERFACE_NO == 4)
;;;234    		M8266HostIf_SPI_SetSpeed(SPI_BaudRatePrescaler_4);				// Setup SPI Clock. Here 84/4 = 21.0MHz for STM32F4xx SPI1 or SPI4, up to 40MHz, since SPI1/4 clock devided from faster APB2 clock
;;;235      #elif (M8266WIFI_SPI_INTERFACE_NO == 2) || (M8266WIFI_SPI_INTERFACE_NO == 3)
;;;236    		M8266HostIf_SPI_SetSpeed(SPI_BaudRatePrescaler_2);				// Setup SPI Clock. Here 42/2 = 21.0MHz for STM32F4xx SPI2 or SPI3, up to 21MHz, since SPI2/3 clock devided from lowver APB1 clock
;;;237    	#endif
;;;238    	 spi_clk = 21000000;                                                                       
;;;239    
;;;240    #elif  defined(MCU_IS_STM32F7XX)
;;;241      #if (M8266WIFI_SPI_INTERFACE_NO == 1) || (M8266WIFI_SPI_INTERFACE_NO == 4)
;;;242        M8266HostIf_SPI_SetSpeed(SPI_BaudRatePrescaler_4);					// Setup SPI Clock. Here 108/4 = 27MHz for STM32F7xx, up to 40MHz
;;;243    	#elif (M8266WIFI_SPI_INTERFACE_NO == 2) || (M8266WIFI_SPI_INTERFACE_NO == 3)
;;;244        M8266HostIf_SPI_SetSpeed(SPI_BaudRatePrescaler_2);					// Setup SPI Clock. Here 54/2  = 27MHz for STM32F7xx
;;;245    	#endif
;;;246    		 spi_clk = 27000000;
;;;247    
;;;248    #elif  defined(MCU_IS_STM32L1XX)
;;;249        M8266HostIf_SPI_SetSpeed(SPI_BaudRatePrescaler_2);				// Setup SPI Clock. Here 32/2  = 16MHz for STM32L1xx
;;;250    		spi_clk = 16000000;
;;;251    
;;;252    #elif  defined(MCU_IS_STM32L4XX)
;;;253        M8266HostIf_SPI_SetSpeed(SPI_BaudRatePrescaler_4);				// Setup SPI Clock. Here 80/4  = 20MHz for STM32L4xx
;;;254    		spi_clk = 20000000;
;;;255    		 
;;;256    #elif  defined(MCU_IS_STM32H7XX)
;;;257      #if (M8266WIFI_SPI_INTERFACE_NO == 1) || (M8266WIFI_SPI_INTERFACE_NO == 2) || (M8266WIFI_SPI_INTERFACE_NO == 3)
;;;258        M8266HostIf_SPI_SetSpeed(SPI_BAUDRATEPRESCALER_8);			// Setup SPI Clock. Here 200/8 = 25MHz for STM32F7xx, up to 40MHz
;;;259    	#elif	(M8266WIFI_SPI_INTERFACE_NO == 4) || (M8266WIFI_SPI_INTERFACE_NO == 5)
;;;260        M8266HostIf_SPI_SetSpeed(SPI_BAUDRATEPRESCALER_4);			// Setup SPI Clock. Here 100/4 = 25MHz for STM32F7xx, up to 40MHz
;;;261    	#endif
;;;262    		 spi_clk = 25000000;
;;;263    
;;;264    #elif  defined(MCU_IS_NXP_LPC17XX)
;;;265       M8266HostIf_SPI_SetSpeed(SPI_BaudRatePrescaler_4);					// Setup SPI Clock. Here 96/4 = 24MHz for LPC17XX, upto 40MHz
;;;266    	 spi_clk = 24000000;
;;;267    
;;;268    #elif  defined(MCU_IS_NXP_MK27_28)
;;;269       M8266HostIf_SPI_SetSpeed(SPI_BaudRatePrescaler_2);					// Setup SPI Clock. Here 37.5/2 = 18.75 MHz for for MK27/28.
;;;270    	 spi_clk = 18750000;
;;;271    
;;;272    #elif  defined(MCU_IS_NuMicro_M451)
;;;273       M8266HostIf_SPI_SetSpeed(4);																// Setup SPI Clock. Here 72/4 = 18MHz for Nuvoton M451, upto 40MHz
;;;274    	 spi_clk =  18000000;
;;;275    
;;;276    #elif  defined(MCU_IS_HT32F16XX)
;;;277       M8266HostIf_SPI_SetSpeed(4);																// Setup SPI Clock. Here 72/4 = 18MHz for HT32F165x, upto 40MHz
;;;278    	 spi_clk =  18000000;
;;;279    #else
;;;280    #error YOU SHOULD DEFINED MCU_IS_XXX near line 17 in brd_cfg.h
;;;281    #endif
;;;282    
;;;283    
;;;284       // wait clock stable
;;;285       M8266WIFI_Module_delay_ms(1);
000026  2001              MOVS     r0,#1
000028  f7fffffe          BL       M8266WIFI_Module_delay_ms
;;;286    	 
;;;287    	 
;;;288       //It is very important to call M8266HostIf_SPI_Select() to tell the driver which SPI you used
;;;289     	 //and how faster the SPI clock you used. The function must be called before SPI access
;;;290    	 if(M8266HostIf_SPI_Select((uint32_t)M8266WIFI_INTERFACE_SPI, spi_clk, &status)==0)
00002c  aa04              ADD      r2,sp,#0x10
00002e  4621              MOV      r1,r4
000030  482d              LDR      r0,|L3.232|
000032  f7fffffe          BL       M8266HostIf_SPI_Select
000036  b908              CBNZ     r0,|L3.60|
;;;291       {
;;;292    		   while(1)  
000038  bf00              NOP      
                  |L3.58|
00003a  e7fe              B        |L3.58|
                  |L3.60|
;;;293    			 {
;;;294    #ifdef USE_LED_AND_KEY_FOR_TEST	 // MB LEDs flash in 2Hz uppon errors				 
;;;295    	          LED_set(0, 0); LED_set(1, 0); M8266WIFI_Module_delay_ms(250);
;;;296    			      LED_set(0, 1); LED_set(1, 1); M8266WIFI_Module_delay_ms(250);
;;;297    #endif				 
;;;298    		   }
;;;299       }
;;;300    	 
;;;301    #if 1  // Used to evaluate the high-speed spi communication. Changed to #if 0 to comment it for formal release
;;;302    {
;;;303    	 volatile u32  i, j;
;;;304    	 u8   byte;
;;;305    
;;;306    	 if(M8266WIFI_SPI_Interface_Communication_OK(&byte)==0) 	  									//	if SPI logical Communication failed
00003c  a801              ADD      r0,sp,#4
00003e  f7fffffe          BL       M8266WIFI_SPI_Interface_Communication_OK
000042  b908              CBNZ     r0,|L3.72|
;;;307       {
;;;308    		   while(1)
000044  bf00              NOP      
                  |L3.70|
000046  e7fe              B        |L3.70|
                  |L3.72|
;;;309    			 {
;;;310    #ifdef USE_LED_AND_KEY_FOR_TEST	 // MB LEDs flash in 1Hz uppon errors				 
;;;311    	          LED_set(0, 0); LED_set(1, 0); M8266WIFI_Module_delay_ms(500);
;;;312    			      LED_set(0, 1); LED_set(1, 1); M8266WIFI_Module_delay_ms(500);
;;;313    #endif			 
;;;314    		   }
;;;315    	 }
;;;316       
;;;317    	 i = 100000;
000048  4828              LDR      r0,|L3.236|
00004a  9003              STR      r0,[sp,#0xc]
;;;318    	 j = M8266WIFI_SPI_Interface_Communication_Stress_Test(i);
00004c  9803              LDR      r0,[sp,#0xc]
00004e  f7fffffe          BL       M8266WIFI_SPI_Interface_Communication_Stress_Test
000052  9002              STR      r0,[sp,#8]
;;;319    	 if( (j<i)&&(i-j>5)) 		//  if SPI Communication stress test failed
000054  e9dd0102          LDRD     r0,r1,[sp,#8]
000058  4288              CMP      r0,r1
00005a  d206              BCS      |L3.106|
00005c  e9dd1002          LDRD     r1,r0,[sp,#8]
000060  1a40              SUBS     r0,r0,r1
000062  2805              CMP      r0,#5
000064  d901              BLS      |L3.106|
;;;320       {
;;;321    		   while(1)
000066  bf00              NOP      
                  |L3.104|
000068  e7fe              B        |L3.104|
                  |L3.106|
;;;322    			 {
;;;323    #ifdef USE_LED_AND_KEY_FOR_TEST	 // MB LEDs flash in 1Hz uppon errors				 
;;;324    	          LED_set(0, 0); LED_set(1, 0); M8266WIFI_Module_delay_ms(500);
;;;325    			      LED_set(0, 1); LED_set(1, 1); M8266WIFI_Module_delay_ms(500);
;;;326    #endif
;;;327    		   }
;;;328    	 }
;;;329     }
;;;330    #endif
;;;331     
;;;332    
;;;333    #if 0	   // If you hope to reduce the Max Tx power, you could enable it by change to "#if 1"
;;;334    	//u8 M8266WIFI_SPI_Set_Tx_Max_Power(u8 tx_max_power, u16 *status)
;;;335    	if(M8266WIFI_SPI_Set_Tx_Max_Power(68, &status)==0)   // tx_max_power=68 to set the max tx power of aroud half of manufacture default, i.e. 50mW or 17dBm
;;;336    	  return 0;
;;;337    #endif	
;;;338    
;;;339    
;;;340    
;;;341    #if 0  // If you expect to config or stop the on-module web server, you could enable it by change to "#if 1" and adjust as required
;;;342    {
;;;343    			 //u8 SPI_Set_Web_Server(u8 open_not_shutdown, u16 server_port, u16* status)
;;;344    			 if(SPI_Set_Web_Server(0, 3128, &status)==0)  // 0 -> to shutdown the web_server
;;;345    		   {
;;;346    				  return 0;
;;;347    		   }
;;;348           //u8 SPI_Set_Web_Server(u8 open_not_shutdown, u16 server_port, u16* status)
;;;349         	 if(SPI_Set_Web_Server(1, 3128, &status)==0)  // 1-> to (re-)start the web_server with port = 3128
;;;350    		   {
;;;351    				  return 0;
;;;352    		   }
;;;353    }
;;;354    #endif
;;;355    
;;;356    #if 1 // If you expect to change the op_mode overrding the default loaded from flash on bootup, enable it by "#if 1"
;;;357    {
;;;358    //u8 M8266WIFI_SPI_Set_Opmode(u8 op_mode, u8 saved, u16* status);
;;;359    	if(M8266WIFI_SPI_Set_Opmode(3, 0, &status)==0)  // set to AP Only mode, not saved // 1=STA Only, 2=AP Only, 3=STA+AP //Ä£Ê½Èý
00006a  aa04              ADD      r2,sp,#0x10
00006c  2100              MOVS     r1,#0
00006e  2003              MOVS     r0,#3
000070  f7fffffe          BL       M8266WIFI_SPI_Set_Opmode
000074  b910              CBNZ     r0,|L3.124|
;;;360        return 0;
000076  2000              MOVS     r0,#0
                  |L3.120|
;;;361    }
;;;362    #endif
;;;363    
;;;364    #if 0 // If you expect to change the ap info overrding the default loaded from flash on bootup, enable it by "#if 1"
;;;365    {
;;;366    // u8 M8266WIFI_SPI_Config_AP(u8 ssid[13+1], u8 password[13+1], u8 enc, u8 channel, u8 saved, u16* status);	
;;;367    	if(M8266WIFI_SPI_Config_AP("Anylinkin", "1234567890", 4, 6, 0, &status)==0)  // set to 4=WPA_WPA2_PSK, not saved // 0=OPEN, 1=WEP, 2=WPA_PSK, 3=WPA2_PSK, 4=WPA_WPA2_PSK
;;;368        return 0;
;;;369    }
;;;370    #endif
;;;371    	
;;;372    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
;;;373    // get current op_mode, if STA mode or STA+AP mode, then, wait connection to external AP and getting ip
;;;374    
;;;375    //u8 M8266WIFI_SPI_Get_Opmode(u8* op_mode, u16* status);	
;;;376    	if(M8266WIFI_SPI_Get_Opmode(&sta_ap_mode, &status)==0)  
;;;377        return 0;
;;;378    
;;;379    	
;;;380    	if(  (sta_ap_mode == 1)   // if STA mode
;;;381    	   ||(sta_ap_mode == 3))  // if STA+AP mode
;;;382    	{
;;;383    		
;;;384    #if 0 // If you expect to use smartconfig to config the module, enable here by "#if 1" and prepare to send ssid using your smart devices such as smartphone 
;;;385    		  // u8 M8266WIFI_SPI_Module_SmartConfig(u8 timeout_in_s, u16* status);
;;;386    		     u8 smartconfig_type;
;;;387    				 char smartconfig_phone_ip[15+1]={0};
;;;388             if(M8266WIFI_SPI_Module_SmartConfig(30, &smartconfig_type, smartconfig_phone_ip, &status)==0)
;;;389    				 return 0;
;;;390    #endif		
;;;391    		
;;;392    #if 1 // If you expect to use the SSID and password here overriding the default loaded from on-module SPI flash, enable it by "#if 1", and update the ssid and passowrd with those of your routers connected to.
;;;393    		//u8 M8266WIFI_SPI_STA_Connect_Ap(u8 ssid[32], u8 password[64], u8 saved, u8 timeout_in_s, u16* status);
;;;394     		     if(M8266WIFI_SPI_STA_Connect_Ap("kingsten", "23622033", 0, 20, &status) == 0) // not saved, timeout=20s
;;;395    				 return 0;			 			 
;;;396    #endif
;;;397    			 
;;;398    			 // Wait the module got ip address if it works in STA mode
;;;399    			 //u8 M8266WIFI_SPI_wait_sta_connecting_to_ap_and_get_ip(char* sta_ip, u8 max_wait_time_in_s)
;;;400    		   if(M8266WIFI_SPI_wait_sta_connecting_to_ap_and_get_ip(sta_ip, 10)==0) // max wait 10s to get sta ip
;;;401    		   {
;;;402    				  return 0; 
;;;403    		   }
;;;404    #if 1	// If you expect to to know the reason of failure by above M8266WIFI_SPI_wait_sta_connecting_to_ap_and_get_ip(), enable below
;;;405    			 else
;;;406    			 {
;;;407    					if(M8266WIFI_SPI_Get_STA_Connection_Status(&connection_status, &status)==0)  // connection_status will give the status of last connecting
;;;408    						return 0;
;;;409    			 }
;;;410    #endif
;;;411    			 
;;;412    #if 1	 // these below two functions are just for examples on how to use them. You may or may not use them during module initialisation		 
;;;413    		 //u8 M8266WIFI_SPI_STA_Query_Current_SSID_And_RSSI(char* ssid, u8* rssi, u16* status)
;;;414    			 if(M8266WIFI_SPI_STA_Query_Current_SSID_And_RSSI(ssid, &rssi, &status)==0)
;;;415    				 return 0;
;;;416    #endif
;;;417    			 
;;;418    	} // end to if(  (sta_ap_mode == 1)
;;;419      return 1;
;;;420     }
000078  b014              ADD      sp,sp,#0x50
00007a  bd10              POP      {r4,pc}
                  |L3.124|
00007c  a904              ADD      r1,sp,#0x10           ;376
00007e  a813              ADD      r0,sp,#0x4c           ;376
000080  f7fffffe          BL       M8266WIFI_SPI_Get_Opmode
000084  b908              CBNZ     r0,|L3.138|
000086  2000              MOVS     r0,#0                 ;377
000088  e7f6              B        |L3.120|
                  |L3.138|
00008a  f89d004c          LDRB     r0,[sp,#0x4c]         ;380
00008e  2801              CMP      r0,#1                 ;380
000090  d003              BEQ      |L3.154|
000092  f89d004c          LDRB     r0,[sp,#0x4c]         ;381
000096  2803              CMP      r0,#3                 ;381
000098  d120              BNE      |L3.220|
                  |L3.154|
00009a  a804              ADD      r0,sp,#0x10           ;394
00009c  2314              MOVS     r3,#0x14              ;394
00009e  2200              MOVS     r2,#0                 ;394
0000a0  a113              ADR      r1,|L3.240|
0000a2  9000              STR      r0,[sp,#0]            ;394
0000a4  a015              ADR      r0,|L3.252|
0000a6  f7fffffe          BL       M8266WIFI_SPI_STA_Connect_Ap
0000aa  b908              CBNZ     r0,|L3.176|
0000ac  2000              MOVS     r0,#0                 ;395
0000ae  e7e3              B        |L3.120|
                  |L3.176|
0000b0  210a              MOVS     r1,#0xa               ;400
0000b2  a80e              ADD      r0,sp,#0x38           ;400
0000b4  f7fffffe          BL       M8266WIFI_SPI_wait_sta_connecting_to_ap_and_get_ip
0000b8  b908              CBNZ     r0,|L3.190|
0000ba  2000              MOVS     r0,#0                 ;402
0000bc  e7dc              B        |L3.120|
                  |L3.190|
0000be  a904              ADD      r1,sp,#0x10           ;407
0000c0  a812              ADD      r0,sp,#0x48           ;407
0000c2  f7fffffe          BL       M8266WIFI_SPI_Get_STA_Connection_Status
0000c6  b908              CBNZ     r0,|L3.204|
0000c8  2000              MOVS     r0,#0                 ;408
0000ca  e7d5              B        |L3.120|
                  |L3.204|
0000cc  aa04              ADD      r2,sp,#0x10           ;414
0000ce  a905              ADD      r1,sp,#0x14           ;414
0000d0  a806              ADD      r0,sp,#0x18           ;414
0000d2  f7fffffe          BL       M8266WIFI_SPI_STA_Query_Current_SSID_And_RSSI
0000d6  b908              CBNZ     r0,|L3.220|
0000d8  2000              MOVS     r0,#0                 ;415
0000da  e7cd              B        |L3.120|
                  |L3.220|
0000dc  2001              MOVS     r0,#1                 ;419
0000de  e7cb              B        |L3.120|
;;;421    
                          ENDP

                  |L3.224|
                          DCD      0x02625a00
                  |L3.228|
                          DCD      0x0112a880
                  |L3.232|
                          DCD      0x40013000
                  |L3.236|
                          DCD      0x000186a0
                  |L3.240|
0000f0  32333632          DCB      "23622033",0
0000f4  32303333
0000f8  00      
0000f9  00                DCB      0
0000fa  00                DCB      0
0000fb  00                DCB      0
                  |L3.252|
0000fc  6b696e67          DCB      "kingsten",0
000100  7374656e
000104  00      
000105  00                DCB      0
000106  00                DCB      0
000107  00                DCB      0

                          AREA ||i.M8266WIFI_Module_delay_ms||, CODE, READONLY, ALIGN=1

                  M8266WIFI_Module_delay_ms PROC
;;;22     
;;;23     void M8266WIFI_Module_delay_ms(u16 nms)
000000  b570              PUSH     {r4-r6,lr}
;;;24     {
000002  4604              MOV      r4,r0
;;;25     	 u16 i, j;
;;;26     	 for(i=0; i<nms; i++)
000004  2500              MOVS     r5,#0
000006  e00a              B        |L4.30|
                  |L4.8|
;;;27     	   for(j=0; j<4; j++)									// delay 1ms. Call 4 times of delay_us(250), as M8266HostIf_delay_us(u8 nus), nus max 255
000008  2600              MOVS     r6,#0
00000a  e004              B        |L4.22|
                  |L4.12|
;;;28     	      M8266HostIf_delay_us(250);
00000c  20fa              MOVS     r0,#0xfa
00000e  f7fffffe          BL       M8266HostIf_delay_us
000012  1c70              ADDS     r0,r6,#1              ;27
000014  b286              UXTH     r6,r0                 ;27
                  |L4.22|
000016  2e04              CMP      r6,#4                 ;27
000018  dbf8              BLT      |L4.12|
00001a  1c68              ADDS     r0,r5,#1              ;26
00001c  b285              UXTH     r5,r0                 ;26
                  |L4.30|
00001e  42a5              CMP      r5,r4                 ;26
000020  dbf2              BLT      |L4.8|
;;;29     }
000022  bd70              POP      {r4-r6,pc}
;;;30     
                          ENDP


                          AREA ||i.M8266WIFI_SPI_wait_sta_connecting_to_ap_and_get_ip||, CODE, READONLY, ALIGN=2

                  M8266WIFI_SPI_wait_sta_connecting_to_ap_and_get_ip PROC
;;;76      ***********************************************************************************/
;;;77     u8 M8266WIFI_SPI_wait_sta_connecting_to_ap_and_get_ip(char* sta_ip, u8 max_wait_time_in_s)
000000  b5f8              PUSH     {r3-r7,lr}
;;;78     {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;79     	 u16  i;
;;;80     	 u16  status=0;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;81     	 
;;;82     	 for(i=0; i<1*max_wait_time_in_s; i++)  // max wait
00000a  2500              MOVS     r5,#0
00000c  e012              B        |L5.52|
                  |L5.14|
;;;83     	 {
;;;84     		   if(   (M8266WIFI_SPI_Get_STA_IP_Addr(sta_ip , &status) ==1)
00000e  4669              MOV      r1,sp
000010  4630              MOV      r0,r6
000012  f7fffffe          BL       M8266WIFI_SPI_Get_STA_IP_Addr
000016  2801              CMP      r0,#1
000018  d105              BNE      |L5.38|
;;;85     				   && (strcmp(sta_ip, "0.0.0.0")!=0) )
00001a  a10b              ADR      r1,|L5.72|
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       strcmp
000022  b100              CBZ      r0,|L5.38|
;;;86                break;
000024  e008              B        |L5.56|
                  |L5.38|
;;;87          			 
;;;88     			M8266WIFI_Module_delay_ms(1000);
000026  f44f707a          MOV      r0,#0x3e8
00002a  f7fffffe          BL       M8266WIFI_Module_delay_ms
;;;89     			continue;
00002e  bf00              NOP      
000030  1c68              ADDS     r0,r5,#1              ;82
000032  b285              UXTH     r5,r0                 ;82
                  |L5.52|
000034  42ac              CMP      r4,r5                 ;82
000036  dcea              BGT      |L5.14|
                  |L5.56|
000038  bf00              NOP                            ;86
;;;90        }
;;;91        if(i>=1*max_wait_time_in_s)
00003a  42ac              CMP      r4,r5
00003c  dc01              BGT      |L5.66|
;;;92     		 return 0; // false
00003e  2000              MOVS     r0,#0
                  |L5.64|
;;;93     	 
;;;94     	 return 1;  // true
;;;95     }
000040  bdf8              POP      {r3-r7,pc}
                  |L5.66|
000042  2001              MOVS     r0,#1                 ;94
000044  e7fc              B        |L5.64|
;;;96     
                          ENDP

000046  0000              DCW      0x0000
                  |L5.72|
000048  302e302e          DCB      "0.0.0.0",0
00004c  302e3000

                          AREA ||i.M8266WIFI_Sleep_Module||, CODE, READONLY, ALIGN=1

                  M8266WIFI_Sleep_Module PROC
;;;496     *************************************************************************************/
;;;497    u8 M8266WIFI_Sleep_Module(void)
000000  b508              PUSH     {r3,lr}
;;;498    {
;;;499    	u16 status;
;;;500      //u8 M8266WIFI_SPI_Sleep_Module(u8 sleep_type, u32 time_to_wakeup_in_ms, u16 *status)
;;;501    	if(M8266WIFI_SPI_Sleep_Module(3, 0, &status)==0) //sleep_type=3=deep_sleep
000002  466a              MOV      r2,sp
000004  2100              MOVS     r1,#0
000006  2003              MOVS     r0,#3
000008  f7fffffe          BL       M8266WIFI_SPI_Sleep_Module
00000c  b908              CBNZ     r0,|L6.18|
;;;502    		 return 0;
00000e  2000              MOVS     r0,#0
                  |L6.16|
;;;503    	
;;;504    	return 1;
;;;505    }
000010  bd08              POP      {r3,pc}
                  |L6.18|
000012  2001              MOVS     r0,#1                 ;504
000014  e7fc              B        |L6.16|
;;;506    /*************************************************************************************
                          ENDP


                          AREA ||i.M8266WIFI_Sleep_module_for_some_time_and_then_wakeup_automatically||, CODE, READONLY, ALIGN=1

                  M8266WIFI_Sleep_module_for_some_time_and_then_wakeup_automatically PROC
;;;468     *************************************************************************************/
;;;469    u8 M8266WIFI_Sleep_module_for_some_time_and_then_wakeup_automatically(u16 time_to_wakeup_in_ms)
000000  b538              PUSH     {r3-r5,lr}
;;;470    {
000002  4604              MOV      r4,r0
;;;471    	u16 status;
;;;472      //u8 M8266WIFI_SPI_Sleep_Module(u8 sleep_type, u32 time_to_wakeup_in_ms, u16 *status)
;;;473    	if(M8266WIFI_SPI_Sleep_Module(3,time_to_wakeup_in_ms, &status)==0) //sleep_type=3=deep_sleep
000004  466a              MOV      r2,sp
000006  4621              MOV      r1,r4
000008  2003              MOVS     r0,#3
00000a  f7fffffe          BL       M8266WIFI_SPI_Sleep_Module
00000e  b908              CBNZ     r0,|L7.20|
;;;474    		 return 0;
000010  2000              MOVS     r0,#0
                  |L7.18|
;;;475    
;;;476    	if(time_to_wakeup_in_ms>0) // not a forever sleep
;;;477      {
;;;478    		 M8266HostIf_Set_SPI_nCS_Pin(0);   // set nCS low to enaure the module will reboot from flash after wakeup
;;;479    	   M8266WIFI_Module_delay_ms(time_to_wakeup_in_ms+1000);  // additional 1000ms for bootup time
;;;480    	   M8266HostIf_Set_SPI_nCS_Pin(1);
;;;481    	}
;;;482    	
;;;483    	return 1;
;;;484    }
000012  bd38              POP      {r3-r5,pc}
                  |L7.20|
000014  2c00              CMP      r4,#0                 ;476
000016  dd0a              BLE      |L7.46|
000018  2000              MOVS     r0,#0                 ;478
00001a  f7fffffe          BL       M8266HostIf_Set_SPI_nCS_Pin
00001e  f504717a          ADD      r1,r4,#0x3e8          ;479
000022  b288              UXTH     r0,r1                 ;479
000024  f7fffffe          BL       M8266WIFI_Module_delay_ms
000028  2001              MOVS     r0,#1                 ;480
00002a  f7fffffe          BL       M8266HostIf_Set_SPI_nCS_Pin
                  |L7.46|
00002e  2001              MOVS     r0,#1                 ;483
000030  e7ef              B        |L7.18|
;;;485    
                          ENDP


                          AREA ||i.M8266WIFI_Wakeup_Module||, CODE, READONLY, ALIGN=1

                  M8266WIFI_Wakeup_Module PROC
;;;526     *************************************************************************************/
;;;527    u8 M8266WIFI_Wakeup_Module(void)
000000  b510              PUSH     {r4,lr}
;;;528    {
;;;529    	 return M8266WIFI_Module_Init_Via_SPI();
000002  f7fffffe          BL       M8266WIFI_Module_Init_Via_SPI
;;;530    }
000006  bd10              POP      {r4,pc}
                          ENDP

