; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\dht11.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\dht11.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS -I..\..\User -I..\..\Libraries\FWlib\inc -I..\..\User\FATFS\option -I..\..\User\FATFS -I..\..\User\delay -I..\..\User\onenet\inc -I..\..\User\device\inc -I..\..\User\EDP -I..\..\User\onenet\inc -I..\..\User\hwtimer -I..\..\User\JPEGENCODE -I..\..\User\MALLOC -I..\..\User\dht11 -I..\..\User\flame -I..\..\User\warning -I..\..\User\beep -I..\..\User\adc -I..\..\User\IIC -I..\..\Freee-RTOS\include -I..\..\Freee-RTOS\portable\RVDS\ARM_CM3 -I..\..\User\IWDG -I..\..\User\light_moto -I..\..\User\M8266WIFI -I.\RTE\_____ -IF:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IF:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\..\output\dht11.crf ..\..\User\dht11\dht11.c]
                          THUMB

                          AREA ||i.DHT11_GPIO_Config||, CODE, READONLY, ALIGN=2

                  DHT11_GPIO_Config PROC
;;;42     */
;;;43     void DHT11_GPIO_Config(void)
000000  b508              PUSH     {r3,lr}
;;;44     {
;;;45     	GPIO_InitTypeDef GPIO_InitStructure;
;;;46     	
;;;47     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE);
000002  2101              MOVS     r1,#1
000004  2040              MOVS     r0,#0x40
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;48     	
;;;49     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
00000a  2040              MOVS     r0,#0x40
00000c  f8ad0000          STRH     r0,[sp,#0]
;;;50     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000010  2010              MOVS     r0,#0x10
000012  f88d0003          STRB     r0,[sp,#3]
;;;51     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000016  2003              MOVS     r0,#3
000018  f88d0002          STRB     r0,[sp,#2]
;;;52     	GPIO_Init(GPIOE, &GPIO_InitStructure);
00001c  4669              MOV      r1,sp
00001e  4802              LDR      r0,|L1.40|
000020  f7fffffe          BL       GPIO_Init
;;;53     }
000024  bd08              POP      {r3,pc}
;;;54     
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      0x40011800

                          AREA ||i.DHT11_Init||, CODE, READONLY, ALIGN=2

                  DHT11_Init PROC
;;;25     
;;;26     void DHT11_Init(void)
000000  b510              PUSH     {r4,lr}
;;;27     {
;;;28     	DHT11_GPIO_Config();	//DHT11的GPIO端口初始化
000002  f7fffffe          BL       DHT11_GPIO_Config
;;;29     	
;;;30     	DHT11_Dout_1;			//拉高PE.6
000006  2140              MOVS     r1,#0x40
000008  4801              LDR      r0,|L2.16|
00000a  f7fffffe          BL       GPIO_SetBits
;;;31     }
00000e  bd10              POP      {r4,pc}
;;;32     
                          ENDP

                  |L2.16|
                          DCD      0x40011800

                          AREA ||i.DHT11_Mode_IPU||, CODE, READONLY, ALIGN=2

                  DHT11_Mode_IPU PROC
;;;64     */
;;;65     void DHT11_Mode_IPU(void)
000000  b508              PUSH     {r3,lr}
;;;66     {
;;;67     	GPIO_InitTypeDef GPIO_InitStructure;
;;;68     	
;;;69     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
000002  2040              MOVS     r0,#0x40
000004  f8ad0000          STRH     r0,[sp,#0]
;;;70     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
000008  2048              MOVS     r0,#0x48
00000a  f88d0003          STRB     r0,[sp,#3]
;;;71     	GPIO_Init(GPIOE, &GPIO_InitStructure);
00000e  4669              MOV      r1,sp
000010  4801              LDR      r0,|L3.24|
000012  f7fffffe          BL       GPIO_Init
;;;72     }
000016  bd08              POP      {r3,pc}
;;;73     
                          ENDP

                  |L3.24|
                          DCD      0x40011800

                          AREA ||i.DHT11_Mode_Out_PP||, CODE, READONLY, ALIGN=2

                  DHT11_Mode_Out_PP PROC
;;;83     */
;;;84     void DHT11_Mode_Out_PP(void)
000000  b508              PUSH     {r3,lr}
;;;85     {
;;;86     	GPIO_InitTypeDef GPIO_InitStructure;
;;;87     	
;;;88     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
000002  2040              MOVS     r0,#0x40
000004  f8ad0000          STRH     r0,[sp,#0]
;;;89     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000008  2010              MOVS     r0,#0x10
00000a  f88d0003          STRB     r0,[sp,#3]
;;;90     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00000e  2003              MOVS     r0,#3
000010  f88d0002          STRB     r0,[sp,#2]
;;;91     	GPIO_Init(GPIOE, &GPIO_InitStructure);
000014  4669              MOV      r1,sp
000016  4802              LDR      r0,|L4.32|
000018  f7fffffe          BL       GPIO_Init
;;;92     }
00001c  bd08              POP      {r3,pc}
;;;93     
                          ENDP

00001e  0000              DCW      0x0000
                  |L4.32|
                          DCD      0x40011800

                          AREA ||i.DHT11_ReadByte||, CODE, READONLY, ALIGN=2

                  DHT11_ReadByte PROC
;;;103    */
;;;104    uint8_t DHT11_ReadByte(void)
000000  b570              PUSH     {r4-r6,lr}
;;;105    {
;;;106    	uint8_t i = 0;
000002  2400              MOVS     r4,#0
;;;107    	uint8_t temp = 0;
000004  2500              MOVS     r5,#0
;;;108    	
;;;109    	for(i = 0; i < 8; i++)
000006  bf00              NOP      
000008  e024              B        |L5.84|
                  |L5.10|
;;;110    	{
;;;111    		//每bit以50us低电平标置开始，轮询直到从机发出的50us低电平结束
;;;112    		while(DHT11_Dout_IN == Bit_RESET){};
00000a  bf00              NOP      
                  |L5.12|
00000c  2140              MOVS     r1,#0x40
00000e  4813              LDR      r0,|L5.92|
000010  f7fffffe          BL       GPIO_ReadInputDataBit
000014  2800              CMP      r0,#0
000016  d0f9              BEQ      |L5.12|
;;;113    			
;;;114    		/*DHT11 以50us的低电平 + 26~28us的高电平表示“0”，以50us的低电平 + 70us高电平表示“1”，
;;;115    		通过检测 x us后的电平即可区别这两个状 ，x 即下面的延时*/
;;;116    		DHT11_delay_us(35);								//延时x us 这个延时需要大于数据0持续的时间即可
000018  2023              MOVS     r0,#0x23
00001a  f7fffffe          BL       DHT11_delay_us
;;;117    		
;;;118    			
;;;119    		if(DHT11_Dout_IN == Bit_SET)				//x us后仍为高电平表示数据“1” 
00001e  2140              MOVS     r1,#0x40
000020  480e              LDR      r0,|L5.92|
000022  f7fffffe          BL       GPIO_ReadInputDataBit
000026  2801              CMP      r0,#1
000028  d10d              BNE      |L5.70|
;;;120    		{
;;;121    			while(DHT11_Dout_IN == Bit_SET){};		//等待数据1的高电平结束
00002a  bf00              NOP      
                  |L5.44|
00002c  2140              MOVS     r1,#0x40
00002e  480b              LDR      r0,|L5.92|
000030  f7fffffe          BL       GPIO_ReadInputDataBit
000034  2801              CMP      r0,#1
000036  d0f9              BEQ      |L5.44|
;;;122    					
;;;123    			temp |= (u8)(0x01 << (7 - i));			//把第7-i位置1，MSB先行
000038  f1c40107          RSB      r1,r4,#7
00003c  2001              MOVS     r0,#1
00003e  4088              LSLS     r0,r0,r1
000040  b2c0              UXTB     r0,r0
000042  4305              ORRS     r5,r5,r0
000044  e004              B        |L5.80|
                  |L5.70|
;;;124    		}
;;;125    		else										// x us后为低电平表示数据“0”
;;;126    		{
;;;127    			temp &= (u8)~(0x01 << (7 - i));			//把第7-i位置0，MSB先行
000046  f1c40107          RSB      r1,r4,#7
00004a  2001              MOVS     r0,#1
00004c  4088              LSLS     r0,r0,r1
00004e  4385              BICS     r5,r5,r0
                  |L5.80|
000050  1c60              ADDS     r0,r4,#1              ;109
000052  b2c4              UXTB     r4,r0                 ;109
                  |L5.84|
000054  2c08              CMP      r4,#8                 ;109
000056  dbd8              BLT      |L5.10|
;;;128    		}
;;;129    	}
;;;130    	return temp;
000058  4628              MOV      r0,r5
;;;131    }
00005a  bd70              POP      {r4-r6,pc}
;;;132    
                          ENDP

                  |L5.92|
                          DCD      0x40011800

                          AREA ||i.DHT11_Read_TempAndHumidity||, CODE, READONLY, ALIGN=2

                  DHT11_Read_TempAndHumidity PROC
;;;144    */
;;;145    uint8_t DHT11_Read_TempAndHumidity(DHT11_Data_TypeDef *DHT11_Data)
000000  b510              PUSH     {r4,lr}
;;;146    {
000002  4604              MOV      r4,r0
;;;147    	DHT11_Mode_Out_PP();				//引脚设为输出
000004  f7fffffe          BL       DHT11_Mode_Out_PP
;;;148    	DHT11_Dout_0;						//主机拉低
000008  2140              MOVS     r1,#0x40
00000a  4824              LDR      r0,|L6.156|
00000c  f7fffffe          BL       GPIO_ResetBits
;;;149    	DHT11_delay_ms(18);						//延时18ms
000010  2012              MOVS     r0,#0x12
000012  f7fffffe          BL       DHT11_delay_ms
;;;150    
;;;151    	DHT11_Dout_1;						//总线拉高
000016  2140              MOVS     r1,#0x40
000018  4820              LDR      r0,|L6.156|
00001a  f7fffffe          BL       GPIO_SetBits
;;;152    	DHT11_delay_us(30);						//主机延时30us
00001e  201e              MOVS     r0,#0x1e
000020  f7fffffe          BL       DHT11_delay_us
;;;153    
;;;154    	DHT11_Mode_IPU();					//主机设为输入，判断从机响应信号
000024  f7fffffe          BL       DHT11_Mode_IPU
;;;155    
;;;156    	//判断从机是否有低电平响应信号 如不响应则跳出，响应则向下运行   
;;;157    	if(DHT11_Dout_IN == Bit_RESET)     
000028  2140              MOVS     r1,#0x40
00002a  481c              LDR      r0,|L6.156|
00002c  f7fffffe          BL       GPIO_ReadInputDataBit
000030  bb80              CBNZ     r0,|L6.148|
;;;158    	{
;;;159    		//轮询直到从机发出80us低电平 作为应答信号 
;;;160    		while(DHT11_Dout_IN == Bit_RESET){};
000032  bf00              NOP      
                  |L6.52|
000034  2140              MOVS     r1,#0x40
000036  4819              LDR      r0,|L6.156|
000038  f7fffffe          BL       GPIO_ReadInputDataBit
00003c  2800              CMP      r0,#0
00003e  d0f9              BEQ      |L6.52|
;;;161    
;;;162    		//轮询直到从机发出的80us高电平 通知微处理器准备接收数据
;;;163    		while(DHT11_Dout_IN == Bit_SET){};
000040  bf00              NOP      
                  |L6.66|
000042  2140              MOVS     r1,#0x40
000044  4815              LDR      r0,|L6.156|
000046  f7fffffe          BL       GPIO_ReadInputDataBit
00004a  2801              CMP      r0,#1
00004c  d0f9              BEQ      |L6.66|
;;;164    
;;;165    		//开始接收数据   
;;;166    		DHT11_Data->humi_int = DHT11_ReadByte();
00004e  f7fffffe          BL       DHT11_ReadByte
000052  7020              STRB     r0,[r4,#0]
;;;167    		DHT11_Data->humi_deci = DHT11_ReadByte();
000054  f7fffffe          BL       DHT11_ReadByte
000058  7060              STRB     r0,[r4,#1]
;;;168    		DHT11_Data->temp_int = DHT11_ReadByte();
00005a  f7fffffe          BL       DHT11_ReadByte
00005e  70a0              STRB     r0,[r4,#2]
;;;169    		DHT11_Data->temp_deci = DHT11_ReadByte();
000060  f7fffffe          BL       DHT11_ReadByte
000064  70e0              STRB     r0,[r4,#3]
;;;170    		DHT11_Data->check_sum = DHT11_ReadByte();
000066  f7fffffe          BL       DHT11_ReadByte
00006a  7120              STRB     r0,[r4,#4]
;;;171    
;;;172    		DHT11_Mode_Out_PP();			//读取结束，引脚改为输出模式
00006c  f7fffffe          BL       DHT11_Mode_Out_PP
;;;173    		DHT11_Dout_1;					//主机拉高
000070  2140              MOVS     r1,#0x40
000072  480a              LDR      r0,|L6.156|
000074  f7fffffe          BL       GPIO_SetBits
;;;174    
;;;175    		//检查读取的数据是否正确
;;;176    		if(DHT11_Data->check_sum == DHT11_Data->humi_int + DHT11_Data->humi_deci + DHT11_Data->temp_int + DHT11_Data->temp_deci)
000078  7820              LDRB     r0,[r4,#0]
00007a  7861              LDRB     r1,[r4,#1]
00007c  4408              ADD      r0,r0,r1
00007e  78a1              LDRB     r1,[r4,#2]
000080  4408              ADD      r0,r0,r1
000082  78e1              LDRB     r1,[r4,#3]
000084  4408              ADD      r0,r0,r1
000086  7921              LDRB     r1,[r4,#4]
000088  4288              CMP      r0,r1
00008a  d101              BNE      |L6.144|
;;;177    		{
;;;178    			return SUCCESS;
00008c  2001              MOVS     r0,#1
                  |L6.142|
;;;179    		}
;;;180    		else 
;;;181    		{    
;;;182    			return ERROR;
;;;183    		}
;;;184    	}
;;;185    	else
;;;186    	{
;;;187    		return ERROR;
;;;188    	}
;;;189    }
00008e  bd10              POP      {r4,pc}
                  |L6.144|
000090  2000              MOVS     r0,#0                 ;182
000092  e7fc              B        |L6.142|
                  |L6.148|
000094  e7ff              B        |L6.150|
                  |L6.150|
000096  2000              MOVS     r0,#0                 ;187
000098  e7f9              B        |L6.142|
;;;190    
                          ENDP

00009a  0000              DCW      0x0000
                  |L6.156|
                          DCD      0x40011800

                          AREA ||i.DHT11_delay_ms||, CODE, READONLY, ALIGN=1

                  DHT11_delay_ms PROC
;;;15     
;;;16     void DHT11_delay_ms(u32 z)
000000  b530              PUSH     {r4,r5,lr}
;;;17     {
000002  4604              MOV      r4,r0
;;;18       u32 i=1000*z;
000004  f44f707a          MOV      r0,#0x3e8
000008  fb04f500          MUL      r5,r4,r0
;;;19     	DHT11_delay_us(i);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       DHT11_delay_us
;;;20     
;;;21     }
000012  bd30              POP      {r4,r5,pc}
;;;22     
                          ENDP


                          AREA ||i.DHT11_delay_us||, CODE, READONLY, ALIGN=1

                  DHT11_delay_us PROC
;;;4      
;;;5      void DHT11_delay_us(u32 time)
000000  2100              MOVS     r1,#0
;;;6      { 
;;;7      	u16 i=0;  
;;;8         while(time--)
000002  e006              B        |L8.18|
                  |L8.4|
;;;9         {
;;;10           i=10;  //自己定义
000004  210a              MOVS     r1,#0xa
;;;11           while(i--) ;    
000006  bf00              NOP      
                  |L8.8|
000008  1e0a              SUBS     r2,r1,#0
00000a  f1a10301          SUB      r3,r1,#1
00000e  b299              UXTH     r1,r3
000010  d1fa              BNE      |L8.8|
                  |L8.18|
000012  1e02              SUBS     r2,r0,#0              ;8
000014  f1a00001          SUB      r0,r0,#1              ;8
000018  d1f4              BNE      |L8.4|
;;;12        }
;;;13     
;;;14     }
00001a  4770              BX       lr
;;;15     
                          ENDP

