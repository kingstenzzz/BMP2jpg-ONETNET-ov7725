; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\bsp_usart.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\bsp_usart.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS -I..\..\User -I..\..\Libraries\FWlib\inc -I..\..\User\FATFS\option -I..\..\User\FATFS -I..\..\User\delay -I..\..\User\onenet\inc -I..\..\User\device\inc -I..\..\User\EDP -I..\..\User\onenet\inc -I..\..\User\hwtimer -I..\..\User\JPEGENCODE -I..\..\User\MALLOC -I..\..\User\dht11 -I..\..\User\flame -I..\..\User\warning -I..\..\User\beep -I..\..\User\adc -I..\..\User\IIC -I..\..\Freee-RTOS\include -I..\..\Freee-RTOS\portable\RVDS\ARM_CM3 -I..\..\User\IWDG -I..\..\User\light_moto -I..\..\User\M8266WIFI -I.\RTE\_____ -IF:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IF:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\..\output\bsp_usart.crf ..\..\User\usart\bsp_usart.c]
                          THUMB

                          AREA ||i.USART_Config||, CODE, READONLY, ALIGN=2

                  USART_Config PROC
;;;9        */
;;;10     void USART_Config(void)
000000  b500              PUSH     {lr}
;;;11     {
000002  b085              SUB      sp,sp,#0x14
;;;12     	GPIO_InitTypeDef GPIO_InitStructure;
;;;13     	USART_InitTypeDef USART_InitStructure;
;;;14     	NVIC_InitTypeDef nvic_initstruct;
;;;15     
;;;16     	// 打开串口GPIO的时钟
;;;17     	DEBUG_USART_GPIO_APBxClkCmd(DEBUG_USART_GPIO_CLK, ENABLE);
000004  2101              MOVS     r1,#1
000006  2004              MOVS     r0,#4
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;18     	
;;;19     	// 打开串口外设的时钟
;;;20     	DEBUG_USART_APBxClkCmd(DEBUG_USART_CLK, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0388              LSLS     r0,r1,#14
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;21     
;;;22     	// 将USART Tx的GPIO配置为推挽复用模式
;;;23     	GPIO_InitStructure.GPIO_Pin = DEBUG_USART_TX_GPIO_PIN;
000014  f44f7000          MOV      r0,#0x200
000018  f8ad0010          STRH     r0,[sp,#0x10]
;;;24     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00001c  2018              MOVS     r0,#0x18
00001e  f88d0013          STRB     r0,[sp,#0x13]
;;;25     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000022  2003              MOVS     r0,#3
000024  f88d0012          STRB     r0,[sp,#0x12]
;;;26     	GPIO_Init(DEBUG_USART_TX_GPIO_PORT, &GPIO_InitStructure);
000028  a904              ADD      r1,sp,#0x10
00002a  4813              LDR      r0,|L1.120|
00002c  f7fffffe          BL       GPIO_Init
;;;27     
;;;28       // 将USART Rx的GPIO配置为浮空输入模式
;;;29     	GPIO_InitStructure.GPIO_Pin = DEBUG_USART_RX_GPIO_PIN;
000030  f44f6080          MOV      r0,#0x400
000034  f8ad0010          STRH     r0,[sp,#0x10]
;;;30     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000038  2004              MOVS     r0,#4
00003a  f88d0013          STRB     r0,[sp,#0x13]
;;;31     	GPIO_Init(DEBUG_USART_RX_GPIO_PORT, &GPIO_InitStructure);
00003e  a904              ADD      r1,sp,#0x10
000040  480d              LDR      r0,|L1.120|
000042  f7fffffe          BL       GPIO_Init
;;;32     	
;;;33     	// 配置串口的工作参数
;;;34     	// 配置波特率
;;;35     	USART_InitStructure.USART_BaudRate = DEBUG_USART_BAUDRATE;
000046  f44f30e1          MOV      r0,#0x1c200
00004a  9000              STR      r0,[sp,#0]
;;;36     	// 配置 针数据字长
;;;37     	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00004c  2000              MOVS     r0,#0
00004e  f8ad0004          STRH     r0,[sp,#4]
;;;38     	// 配置停止位
;;;39     	USART_InitStructure.USART_StopBits = USART_StopBits_1;
000052  f8ad0006          STRH     r0,[sp,#6]
;;;40     	// 配置校验位
;;;41     	USART_InitStructure.USART_Parity = USART_Parity_No ;
000056  f8ad0008          STRH     r0,[sp,#8]
;;;42     	// 配置硬件流控制
;;;43     	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00005a  f8ad000c          STRH     r0,[sp,#0xc]
;;;44     	// 配置工作模式，收发一起
;;;45     	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00005e  200c              MOVS     r0,#0xc
000060  f8ad000a          STRH     r0,[sp,#0xa]
;;;46     	// 完成串口的初始化配置
;;;47     	USART_Init(DEBUG_USARTx, &USART_InitStructure);
000064  4669              MOV      r1,sp
000066  4805              LDR      r0,|L1.124|
000068  f7fffffe          BL       USART_Init
;;;48     //	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);									//使能接收中断
;;;49     	
;;;50     	
;;;51     	// 使能串口
;;;52     	USART_Cmd(DEBUG_USARTx, ENABLE);	    
00006c  2101              MOVS     r1,#1
00006e  4803              LDR      r0,|L1.124|
000070  f7fffffe          BL       USART_Cmd
;;;53     }
000074  b005              ADD      sp,sp,#0x14
000076  bd00              POP      {pc}
;;;54     
                          ENDP

                  |L1.120|
                          DCD      0x40010800
                  |L1.124|
                          DCD      0x40013800

                          AREA ||i.USART_Send2Byre||, CODE, READONLY, ALIGN=2

                  USART_Send2Byre PROC
;;;128    
;;;129    void USART_Send2Byre(USART_TypeDef* USARTx, u16 data)
000000  b570              PUSH     {r4-r6,lr}
;;;130    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;131    	USART_SendByre(USART2, (u8)data);
000006  b2e1              UXTB     r1,r4
000008  4803              LDR      r0,|L2.24|
00000a  f7fffffe          BL       USART_SendByre
;;;132    	USART_SendByre(USART2, (u8)(data>>8));
00000e  1221              ASRS     r1,r4,#8
000010  4801              LDR      r0,|L2.24|
000012  f7fffffe          BL       USART_SendByre
;;;133    }
000016  bd70              POP      {r4-r6,pc}
;;;134    
                          ENDP

                  |L2.24|
                          DCD      0x40004400

                          AREA ||i.USART_SendByre||, CODE, READONLY, ALIGN=1

                  USART_SendByre PROC
;;;122    
;;;123    void USART_SendByre(USART_TypeDef* USARTx, u8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;124    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;125    	USART_SendData(USARTx, data);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       USART_SendData
;;;126    	while(USART_GetFlagStatus(USARTx, USART_FLAG_TC) == RESET);
00000e  bf00              NOP      
                  |L3.16|
000010  2140              MOVS     r1,#0x40
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       USART_GetFlagStatus
000018  2800              CMP      r0,#0
00001a  d0f9              BEQ      |L3.16|
;;;127    }
00001c  bd70              POP      {r4-r6,pc}
;;;128    
                          ENDP


                          AREA ||i.Usart3_Init||, CODE, READONLY, ALIGN=2

                  Usart3_Init PROC
;;;56     
;;;57     void Usart3_Init(unsigned int baud)///wifi串口
000000  b510              PUSH     {r4,lr}
;;;58     {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;59     GPIO_InitTypeDef gpio_initstruct;
;;;60     	USART_InitTypeDef usart_initstruct;
;;;61     	NVIC_InitTypeDef nvic_initstruct;
;;;62     	
;;;63     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD|RCC_APB2Periph_AFIO, ENABLE);
000006  2101              MOVS     r1,#1
000008  2021              MOVS     r0,#0x21
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;64     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
00000e  2101              MOVS     r1,#1
000010  0488              LSLS     r0,r1,#18
000012  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;65     	GPIO_PinRemapConfig(GPIO_FullRemap_USART3,ENABLE);
000016  2101              MOVS     r1,#1
000018  4824              LDR      r0,|L4.172|
00001a  f7fffffe          BL       GPIO_PinRemapConfig
;;;66     	//PA2	TXD
;;;67     	gpio_initstruct.GPIO_Mode = GPIO_Mode_AF_PP;
00001e  2018              MOVS     r0,#0x18
000020  f88d0017          STRB     r0,[sp,#0x17]
;;;68     	gpio_initstruct.GPIO_Pin = GPIO_Pin_8;
000024  f44f7080          MOV      r0,#0x100
000028  f8ad0014          STRH     r0,[sp,#0x14]
;;;69     	gpio_initstruct.GPIO_Speed = GPIO_Speed_50MHz;
00002c  2003              MOVS     r0,#3
00002e  f88d0016          STRB     r0,[sp,#0x16]
;;;70     	GPIO_Init(GPIOD, &gpio_initstruct);
000032  a905              ADD      r1,sp,#0x14
000034  481e              LDR      r0,|L4.176|
000036  f7fffffe          BL       GPIO_Init
;;;71     	
;;;72     	//PA3	RXD
;;;73     	gpio_initstruct.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00003a  2004              MOVS     r0,#4
00003c  f88d0017          STRB     r0,[sp,#0x17]
;;;74     	gpio_initstruct.GPIO_Pin = GPIO_Pin_9;
000040  01c0              LSLS     r0,r0,#7
000042  f8ad0014          STRH     r0,[sp,#0x14]
;;;75     	gpio_initstruct.GPIO_Speed = GPIO_Speed_50MHz;
000046  2003              MOVS     r0,#3
000048  f88d0016          STRB     r0,[sp,#0x16]
;;;76     	GPIO_Init(GPIOD, &gpio_initstruct);
00004c  a905              ADD      r1,sp,#0x14
00004e  4818              LDR      r0,|L4.176|
000050  f7fffffe          BL       GPIO_Init
;;;77     	
;;;78     	usart_initstruct.USART_BaudRate = baud;
000054  9401              STR      r4,[sp,#4]
;;;79     	usart_initstruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;		//无硬件流控
000056  2000              MOVS     r0,#0
000058  f8ad0010          STRH     r0,[sp,#0x10]
;;;80     	usart_initstruct.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;						//接收和发送
00005c  200c              MOVS     r0,#0xc
00005e  f8ad000e          STRH     r0,[sp,#0xe]
;;;81     	usart_initstruct.USART_Parity = USART_Parity_No;									//无校验
000062  2000              MOVS     r0,#0
000064  f8ad000c          STRH     r0,[sp,#0xc]
;;;82     	usart_initstruct.USART_StopBits = USART_StopBits_1;								//1位停止位
000068  f8ad000a          STRH     r0,[sp,#0xa]
;;;83     	usart_initstruct.USART_WordLength = USART_WordLength_8b;							//8位数据位
00006c  f8ad0008          STRH     r0,[sp,#8]
;;;84     	USART_Init(USART3, &usart_initstruct);
000070  a901              ADD      r1,sp,#4
000072  4810              LDR      r0,|L4.180|
000074  f7fffffe          BL       USART_Init
;;;85     	
;;;86     	USART_Cmd(USART3, ENABLE);														//使能串口
000078  2101              MOVS     r1,#1
00007a  480e              LDR      r0,|L4.180|
00007c  f7fffffe          BL       USART_Cmd
;;;87     	
;;;88     	USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);									//使能接收中断
000080  2201              MOVS     r2,#1
000082  f2405125          MOV      r1,#0x525
000086  480b              LDR      r0,|L4.180|
000088  f7fffffe          BL       USART_ITConfig
;;;89     	
;;;90     	nvic_initstruct.NVIC_IRQChannel = USART3_IRQn;
00008c  2027              MOVS     r0,#0x27
00008e  f88d0000          STRB     r0,[sp,#0]
;;;91     	nvic_initstruct.NVIC_IRQChannelCmd = ENABLE;
000092  2001              MOVS     r0,#1
000094  f88d0003          STRB     r0,[sp,#3]
;;;92     	nvic_initstruct.NVIC_IRQChannelPreemptionPriority = 0;
000098  2000              MOVS     r0,#0
00009a  f88d0001          STRB     r0,[sp,#1]
;;;93     	nvic_initstruct.NVIC_IRQChannelSubPriority = 0;
00009e  f88d0002          STRB     r0,[sp,#2]
;;;94     	NVIC_Init(&nvic_initstruct);
0000a2  4668              MOV      r0,sp
0000a4  f7fffffe          BL       NVIC_Init
;;;95     
;;;96     }
0000a8  b006              ADD      sp,sp,#0x18
0000aa  bd10              POP      {r4,pc}
;;;97     
                          ENDP

                  |L4.172|
                          DCD      0x00140030
                  |L4.176|
                          DCD      0x40011400
                  |L4.180|
                          DCD      0x40004800

                          AREA ||i.UsartPrintf||, CODE, READONLY, ALIGN=1

                  UsartPrintf PROC
;;;147    }
;;;148    void UsartPrintf(USART_TypeDef *USARTx, char *fmt,...)
000000  b40f              PUSH     {r0-r3}
;;;149    {
000002  b530              PUSH     {r4,r5,lr}
000004  b0cb              SUB      sp,sp,#0x12c
000006  4605              MOV      r5,r0
;;;150    
;;;151    	unsigned char UsartPrintfBuf[296];
;;;152    	va_list ap;
;;;153    	unsigned char *pStr = UsartPrintfBuf;
000008  ac01              ADD      r4,sp,#4
;;;154    	
;;;155    	va_start(ap, fmt);
00000a  a850              ADD      r0,sp,#0x140
00000c  9000              STR      r0,[sp,#0]
;;;156    	vsnprintf((char *)UsartPrintfBuf, sizeof(UsartPrintfBuf), fmt, ap);							//格式化
00000e  f44f7194          MOV      r1,#0x128
000012  a801              ADD      r0,sp,#4
000014  9b00              LDR      r3,[sp,#0]
000016  9a4f              LDR      r2,[sp,#0x13c]
000018  f7fffffe          BL       vsnprintf
;;;157    	va_end(ap);
00001c  2000              MOVS     r0,#0
00001e  9000              STR      r0,[sp,#0]
;;;158    	
;;;159    	while(*pStr != 0)
000020  e00b              B        |L5.58|
                  |L5.34|
;;;160    	{
;;;161    		USART_SendData(USARTx, *pStr++);
000022  f8141b01          LDRB     r1,[r4],#1
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       USART_SendData
;;;162    		while(USART_GetFlagStatus(USARTx, USART_FLAG_TC) == RESET);
00002c  bf00              NOP      
                  |L5.46|
00002e  2140              MOVS     r1,#0x40
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       USART_GetFlagStatus
000036  2800              CMP      r0,#0
000038  d0f9              BEQ      |L5.46|
                  |L5.58|
00003a  7820              LDRB     r0,[r4,#0]            ;159
00003c  2800              CMP      r0,#0                 ;159
00003e  d1f0              BNE      |L5.34|
;;;163    	}
;;;164    
;;;165    }
000040  b04b              ADD      sp,sp,#0x12c
000042  bc30              POP      {r4,r5}
000044  f85dfb14          LDR      pc,[sp],#0x14
;;;166    
                          ENDP


                          AREA ||i.Usart_SendString||, CODE, READONLY, ALIGN=1

                  Usart_SendString PROC
;;;135    
;;;136    void Usart_SendString(USART_TypeDef *USARTx, unsigned char *str, unsigned short len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;137    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;138    
;;;139    	 unsigned short count = 0;
00000a  2600              MOVS     r6,#0
;;;140    	
;;;141    	for(; count < len; count++)
00000c  e00d              B        |L6.42|
                  |L6.14|
;;;142    	{
;;;143    		USART_SendData(USARTx, *str++);									//发送数据
00000e  f8141b01          LDRB     r1,[r4],#1
000012  4638              MOV      r0,r7
000014  f7fffffe          BL       USART_SendData
;;;144    		while(USART_GetFlagStatus(USARTx, USART_FLAG_TC) == RESET);		//等待发送完成
000018  bf00              NOP      
                  |L6.26|
00001a  2140              MOVS     r1,#0x40
00001c  4638              MOV      r0,r7
00001e  f7fffffe          BL       USART_GetFlagStatus
000022  2800              CMP      r0,#0
000024  d0f9              BEQ      |L6.26|
000026  1c70              ADDS     r0,r6,#1              ;141
000028  b286              UXTH     r6,r0                 ;141
                  |L6.42|
00002a  42ae              CMP      r6,r5                 ;141
00002c  dbef              BLT      |L6.14|
;;;145    	}
;;;146    
;;;147    }
00002e  e8bd81f0          POP      {r4-r8,pc}
;;;148    void UsartPrintf(USART_TypeDef *USARTx, char *fmt,...)
                          ENDP


                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=2

                  fgetc PROC
;;;114    ///重定向c库函数scanf到串口，重写向后可使用scanf、getchar等函数
;;;115    int fgetc(FILE *f)
000000  b510              PUSH     {r4,lr}
;;;116    {
000002  4604              MOV      r4,r0
;;;117    		/* 等待串口输入数据 */
;;;118    		while (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_RXNE) == RESET);
000004  bf00              NOP      
                  |L7.6|
000006  2120              MOVS     r1,#0x20
000008  4804              LDR      r0,|L7.28|
00000a  f7fffffe          BL       USART_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L7.6|
;;;119    
;;;120    		return (int)USART_ReceiveData(DEBUG_USARTx);
000012  4802              LDR      r0,|L7.28|
000014  f7fffffe          BL       USART_ReceiveData
;;;121    }
000018  bd10              POP      {r4,pc}
;;;122    
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      0x40013800

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;102    ///重定向c库函数printf到串口，重定向后可使用printf函数
;;;103    int fputc(int ch, FILE *f)
000000  b570              PUSH     {r4-r6,lr}
;;;104    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;105    		/* 发送一个字节数据到串口 */
;;;106    		USART_SendData(DEBUG_USARTx, (uint8_t) ch);
000006  b2e1              UXTB     r1,r4
000008  4805              LDR      r0,|L8.32|
00000a  f7fffffe          BL       USART_SendData
;;;107    		
;;;108    		/* 等待发送完毕 */
;;;109    		while (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_TXE) == RESET);		
00000e  bf00              NOP      
                  |L8.16|
000010  2180              MOVS     r1,#0x80
000012  4803              LDR      r0,|L8.32|
000014  f7fffffe          BL       USART_GetFlagStatus
000018  2800              CMP      r0,#0
00001a  d0f9              BEQ      |L8.16|
;;;110    	
;;;111    		return (ch);
00001c  4620              MOV      r0,r4
;;;112    }
00001e  bd70              POP      {r4-r6,pc}
;;;113    
                          ENDP

                  |L8.32|
                          DCD      0x40013800
