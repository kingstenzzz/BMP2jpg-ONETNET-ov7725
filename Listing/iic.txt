; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\iic.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\iic.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS -I..\..\User -I..\..\Libraries\FWlib\inc -I..\..\User\FATFS\option -I..\..\User\FATFS -I..\..\User\delay -I..\..\User\onenet\inc -I..\..\User\device\inc -I..\..\User\EDP -I..\..\User\onenet\inc -I..\..\User\hwtimer -I..\..\User\JPEGENCODE -I..\..\User\MALLOC -I..\..\User\dht11 -I..\..\User\flame -I..\..\User\warning -I..\..\User\beep -I..\..\User\adc -I..\..\User\IIC -I..\..\Freee-RTOS\include -I..\..\Freee-RTOS\portable\RVDS\ARM_CM3 -I..\..\User\IWDG -I..\..\User\light_moto -I..\..\User\M8266WIFI -I..\..\User\TIMER -I.\RTE\_____ -IF:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IF:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\..\output\iic.crf ..\..\User\IIC\IIC.c]
                          THUMB

                          AREA ||i.Read_LIMDATA||, CODE, READONLY, ALIGN=2

                  Read_LIMDATA PROC
;;;460     */
;;;461    uint8_t Read_LIMDATA(void ) 
000000  b508              PUSH     {r3,lr}
;;;462    {
;;;463      uint16_t i;
;;;464      uint8_t read_buf[EEPROM_SIZE];
;;;465    
;;;466    
;;;467    	
;;;468      
;;;469    /*-----------------------------------------------------------------------------------*/  
;;;470      if (ee_CheckOk() == 0)
000002  f7fffffe          BL       ee_CheckOk
000006  b920              CBNZ     r0,|L1.18|
;;;471    	{
;;;472    		/* 没有检测到EEPROM */
;;;473    		printf("没有检测到串行EEPROM!\r\n");
000008  a013              ADR      r0,|L1.88|
00000a  f7fffffe          BL       __2printf
;;;474    				
;;;475    		return 0;
00000e  2000              MOVS     r0,#0
                  |L1.16|
;;;476    	}
;;;477    
;;;478    	ee_Delay(0xfffff);
;;;479    
;;;480    /*-----------------------------------------------------------------------------------*/
;;;481      if (ee_ReadBytes(read_buf, 0, EEPROM_SIZE) == 0)
;;;482    	{
;;;483    		printf("读eeprom出错！\r\n");
;;;484    		return 0;
;;;485    	}
;;;486    	else
;;;487    	{		
;;;488    		printf("读eeprom成功，数据如下：\r\n");
;;;489    		humi_max=read_buf[0];
;;;490    		humi_min=read_buf[1];
;;;491    		temp_max=read_buf[2];
;;;492    		temp_min=read_buf[3];
;;;493    	}
;;;494    /*-----------------------------------------------------------------------------------*/  
;;;495    
;;;496      return 1;
;;;497    }
000010  bd08              POP      {r3,pc}
                  |L1.18|
000012  4817              LDR      r0,|L1.112|
000014  f7fffffe          BL       ee_Delay
000018  2204              MOVS     r2,#4                 ;481
00001a  2100              MOVS     r1,#0                 ;481
00001c  4668              MOV      r0,sp                 ;481
00001e  f7fffffe          BL       ee_ReadBytes
000022  b920              CBNZ     r0,|L1.46|
000024  a013              ADR      r0,|L1.116|
000026  f7fffffe          BL       __2printf
00002a  2000              MOVS     r0,#0                 ;484
00002c  e7f0              B        |L1.16|
                  |L1.46|
00002e  a016              ADR      r0,|L1.136|
000030  f7fffffe          BL       __2printf
000034  f89d0000          LDRB     r0,[sp,#0]            ;489
000038  491a              LDR      r1,|L1.164|
00003a  7008              STRB     r0,[r1,#0]            ;489
00003c  f89d0001          LDRB     r0,[sp,#1]            ;490
000040  4919              LDR      r1,|L1.168|
000042  7008              STRB     r0,[r1,#0]            ;490
000044  f89d0002          LDRB     r0,[sp,#2]            ;491
000048  4918              LDR      r1,|L1.172|
00004a  8008              STRH     r0,[r1,#0]            ;491
00004c  f89d0003          LDRB     r0,[sp,#3]            ;492
000050  4917              LDR      r1,|L1.176|
000052  8008              STRH     r0,[r1,#0]            ;492
000054  2001              MOVS     r0,#1                 ;496
000056  e7db              B        |L1.16|
;;;498    	
                          ENDP

                  |L1.88|
000058  c3bbd3d0          DCB      195,187,211,208,188,236,178,226,181,189,180,174,208,208,"E"
00005c  bcecb2e2
000060  b5bdb4ae
000064  d0d045  
000067  4550524f          DCB      "EPROM!\r\n",0
00006b  4d210d0a
00006f  00      
                  |L1.112|
                          DCD      0x000fffff
                  |L1.116|
000074  b6c16565          DCB      182,193,"eeprom",179,246,180,237,163,161,"\r\n",0
000078  70726f6d
00007c  b3f6b4ed
000080  a3a10d0a
000084  00      
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0
                  |L1.136|
000088  b6c16565          DCB      182,193,"eeprom",179,201,185,166,163,172,202,253,190,221
00008c  70726f6d
000090  b3c9b9a6
000094  a3accafd
000098  bedd    
00009a  c8e7cfc2          DCB      200,231,207,194,163,186,"\r\n",0
00009e  a3ba0d0a
0000a2  00      
0000a3  00                DCB      0
                  |L1.164|
                          DCD      humi_max
                  |L1.168|
                          DCD      humi_min
                  |L1.172|
                          DCD      temp_max
                  |L1.176|
                          DCD      temp_min

                          AREA ||i.ee_CheckOk||, CODE, READONLY, ALIGN=1

                  ee_CheckOk PROC
;;;274    */
;;;275    uint8_t ee_CheckOk(void)
000000  b510              PUSH     {r4,lr}
;;;276    {
;;;277    	if (i2c_CheckDevice(EEPROM_DEV_ADDR) == 0)
000002  20a0              MOVS     r0,#0xa0
000004  f7fffffe          BL       i2c_CheckDevice
000008  b908              CBNZ     r0,|L2.14|
;;;278    	{
;;;279    		return 1;
00000a  2001              MOVS     r0,#1
                  |L2.12|
;;;280    	}
;;;281    	else
;;;282    	{
;;;283    		/* 失败后，切记发送I2C总线停止信号 */
;;;284    		i2c_Stop();		
;;;285    		return 0;
;;;286    	}
;;;287    }
00000c  bd10              POP      {r4,pc}
                  |L2.14|
00000e  f7fffffe          BL       i2c_Stop
000012  2000              MOVS     r0,#0                 ;285
000014  e7fa              B        |L2.12|
;;;288    
                          ENDP


                          AREA ||i.ee_Delay||, CODE, READONLY, ALIGN=1

                  ee_Delay PROC
;;;450    /*--------------------------------------------------------------------------------------------------*/
;;;451     void ee_Delay(__IO uint32_t nCount)	 //简单的延时函数
000000  b501              PUSH     {r0,lr}
;;;452    {
;;;453    	for(; nCount != 0; nCount--);
000002  e002              B        |L3.10|
                  |L3.4|
000004  9800              LDR      r0,[sp,#0]
000006  1e40              SUBS     r0,r0,#1
000008  9000              STR      r0,[sp,#0]
                  |L3.10|
00000a  9800              LDR      r0,[sp,#0]
00000c  2800              CMP      r0,#0
00000e  d1f9              BNE      |L3.4|
;;;454    }
000010  bd08              POP      {r3,pc}
;;;455    
                          ENDP


                          AREA ||i.ee_ReadBytes||, CODE, READONLY, ALIGN=1

                  ee_ReadBytes PROC
;;;298    */
;;;299    uint8_t ee_ReadBytes(uint8_t *_pReadBuf, uint16_t _usAddress, uint16_t _usSize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;300    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;301    	uint16_t i;
;;;302    	
;;;303    	/* 采用串行EEPROM随即读取指令序列，连续读取若干字节 */
;;;304    	
;;;305    	/* 第1步：发起I2C总线启动信号 */
;;;306    	i2c_Start();
00000a  f7fffffe          BL       i2c_Start
;;;307    	
;;;308    	/* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;309    	i2c_SendByte(EEPROM_DEV_ADDR | EEPROM_I2C_WR);	/* 此处是写指令 */
00000e  20a0              MOVS     r0,#0xa0
000010  f7fffffe          BL       i2c_SendByte
;;;310    	 
;;;311    	/* 第3步：等待ACK */
;;;312    	if (i2c_WaitAck() != 0)
000014  f7fffffe          BL       i2c_WaitAck
000018  b100              CBZ      r0,|L4.28|
;;;313    	{
;;;314    		goto cmd_fail;	/* EEPROM器件无应答 */
00001a  e025              B        |L4.104|
                  |L4.28|
;;;315    	}
;;;316    
;;;317    	/* 第4步：发送字节地址，24C02只有256字节，因此1个字节就够了，如果是24C04以上，那么此处需要连发多个地址 */
;;;318    	i2c_SendByte((uint8_t)_usAddress);
00001c  b2f8              UXTB     r0,r7
00001e  f7fffffe          BL       i2c_SendByte
;;;319    	
;;;320    	/* 第5步：等待ACK */
;;;321    	if (i2c_WaitAck() != 0)
000022  f7fffffe          BL       i2c_WaitAck
000026  b100              CBZ      r0,|L4.42|
;;;322    	{
;;;323    		goto cmd_fail;	/* EEPROM器件无应答 */
000028  e01e              B        |L4.104|
                  |L4.42|
;;;324    	}
;;;325    	
;;;326    	/* 第6步：重新启动I2C总线。前面的代码的目的向EEPROM传送地址，下面开始读取数据 */
;;;327    	i2c_Start();
00002a  f7fffffe          BL       i2c_Start
;;;328    	
;;;329    	/* 第7步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;330    	i2c_SendByte(EEPROM_DEV_ADDR | EEPROM_I2C_RD);	/* 此处是读指令 */
00002e  20a1              MOVS     r0,#0xa1
000030  f7fffffe          BL       i2c_SendByte
;;;331    	
;;;332    	/* 第8步：发送ACK */
;;;333    	if (i2c_WaitAck() != 0)
000034  f7fffffe          BL       i2c_WaitAck
000038  b100              CBZ      r0,|L4.60|
;;;334    	{
;;;335    		goto cmd_fail;	/* EEPROM器件无应答 */
00003a  e015              B        |L4.104|
                  |L4.60|
;;;336    	}	
;;;337    	
;;;338    	/* 第9步：循环读取数据 */
;;;339    	for (i = 0; i < _usSize; i++)
00003c  2400              MOVS     r4,#0
00003e  e00c              B        |L4.90|
                  |L4.64|
;;;340    	{
;;;341    		_pReadBuf[i] = i2c_ReadByte();	/* 读1个字节 */
000040  f7fffffe          BL       i2c_ReadByte
000044  5530              STRB     r0,[r6,r4]
;;;342    		
;;;343    		/* 每读完1个字节后，需要发送Ack， 最后一个字节不需要Ack，发Nack */
;;;344    		if (i != _usSize - 1)
000046  1e68              SUBS     r0,r5,#1
000048  42a0              CMP      r0,r4
00004a  d002              BEQ      |L4.82|
;;;345    		{
;;;346    			i2c_Ack();	/* 中间字节读完后，CPU产生ACK信号(驱动SDA = 0) */
00004c  f7fffffe          BL       i2c_Ack
000050  e001              B        |L4.86|
                  |L4.82|
;;;347    		}
;;;348    		else
;;;349    		{
;;;350    			i2c_NAck();	/* 最后1个字节读完后，CPU产生NACK信号(驱动SDA = 1) */
000052  f7fffffe          BL       i2c_NAck
                  |L4.86|
000056  1c60              ADDS     r0,r4,#1              ;339
000058  b284              UXTH     r4,r0                 ;339
                  |L4.90|
00005a  42ac              CMP      r4,r5                 ;339
00005c  dbf0              BLT      |L4.64|
;;;351    		}
;;;352    	}
;;;353    	/* 发送I2C总线停止信号 */
;;;354    	i2c_Stop();
00005e  f7fffffe          BL       i2c_Stop
;;;355    	return 1;	/* 执行成功 */
000062  2001              MOVS     r0,#1
                  |L4.100|
;;;356    
;;;357    cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
;;;358    	/* 发送I2C总线停止信号 */
;;;359    	i2c_Stop();
;;;360    	return 0;
;;;361    }
000064  e8bd81f0          POP      {r4-r8,pc}
                  |L4.104|
000068  f7fffffe          BL       i2c_Stop
00006c  2000              MOVS     r0,#0                 ;360
00006e  e7f9              B        |L4.100|
;;;362    
                          ENDP


                          AREA ||i.ee_WriteBytes||, CODE, READONLY, ALIGN=2

                  ee_WriteBytes PROC
;;;372    */
;;;373    uint8_t ee_WriteBytes(uint8_t data, uint16_t _usAddress)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;374    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
;;;375    	uint16_t i,m;
;;;376    	uint16_t usAddr;
;;;377    	
;;;378    	/* 
;;;379    		写串行EEPROM不像读操作可以连续读取很多字节，每次写操作只能在同一个page。
;;;380    		对于24xx02，page size = 8
;;;381    		简单的处理方法为：按字节写操作模式，没写1个字节，都发送地址
;;;382    		为了提高连续写的效率: 本函数采用page wirte操作。
;;;383    	*/
;;;384    
;;;385    	usAddr = _usAddress;	
000008  462e              MOV      r6,r5
;;;386    
;;;387    		/* 当发送第1个字节或是页面首地址时，需要重新发起启动信号和地址 */
;;;388    		if ((i == 0) || (usAddr & (EEPROM_PAGE_SIZE - 1)) == 0)
00000a  f1b80f00          CMP      r8,#0
00000e  d002              BEQ      |L5.22|
000010  f0060007          AND      r0,r6,#7
000014  b9e8              CBNZ     r0,|L5.82|
                  |L5.22|
;;;389    		{
;;;390    			/*　第０步：发停止信号，启动内部写操作　*/
;;;391    			i2c_Stop();
000016  f7fffffe          BL       i2c_Stop
;;;392    			
;;;393    			/* 通过检查器件应答的方式，判断内部写操作是否完成, 一般小于 10ms 			
;;;394    				CLK频率为200KHz时，查询次数为30次左右
;;;395    			*/
;;;396    			for (m = 0; m < 1000; m++)
00001a  2400              MOVS     r4,#0
00001c  e00a              B        |L5.52|
                  |L5.30|
;;;397    			{				
;;;398    				/* 第1步：发起I2C总线启动信号 */
;;;399    				i2c_Start();
00001e  f7fffffe          BL       i2c_Start
;;;400    				
;;;401    				/* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;402    				i2c_SendByte(EEPROM_DEV_ADDR | EEPROM_I2C_WR);	/* 此处是写指令 */
000022  20a0              MOVS     r0,#0xa0
000024  f7fffffe          BL       i2c_SendByte
;;;403    				
;;;404    				/* 第3步：发送一个时钟，判断器件是否正确应答 */
;;;405    				if (i2c_WaitAck() == 0)
000028  f7fffffe          BL       i2c_WaitAck
00002c  b900              CBNZ     r0,|L5.48|
;;;406    				{
;;;407    					break;
00002e  e004              B        |L5.58|
                  |L5.48|
000030  1c60              ADDS     r0,r4,#1              ;396
000032  b284              UXTH     r4,r0                 ;396
                  |L5.52|
000034  f5b47f7a          CMP      r4,#0x3e8             ;396
000038  dbf1              BLT      |L5.30|
                  |L5.58|
00003a  bf00              NOP      
;;;408    				}
;;;409    			}
;;;410    			if (m  == 1000)
00003c  f5b47f7a          CMP      r4,#0x3e8
000040  d100              BNE      |L5.68|
;;;411    			{
;;;412    				goto cmd_fail;	/* EEPROM器件写超时 */
000042  e015              B        |L5.112|
                  |L5.68|
;;;413    			}
;;;414    		
;;;415    			/* 第4步：发送字节地址，24C02只有256字节，因此1个字节就够了，如果是24C04以上，那么此处需要连发多个地址 */
;;;416    			i2c_SendByte((uint8_t)usAddr);
000044  b2f0              UXTB     r0,r6
000046  f7fffffe          BL       i2c_SendByte
;;;417    			
;;;418    			/* 第5步：等待ACK */
;;;419    			if (i2c_WaitAck() != 0)
00004a  f7fffffe          BL       i2c_WaitAck
00004e  b100              CBZ      r0,|L5.82|
;;;420    			{
;;;421    				goto cmd_fail;	/* EEPROM器件无应答 */
000050  e00e              B        |L5.112|
                  |L5.82|
;;;422    			}
;;;423    		}
;;;424    	
;;;425    		/* 第6步：开始写入数据 */
;;;426    		i2c_SendByte(data);
000052  4638              MOV      r0,r7
000054  f7fffffe          BL       i2c_SendByte
;;;427    	
;;;428    		/* 第7步：发送ACK */
;;;429    		if (i2c_WaitAck() != 0)
000058  f7fffffe          BL       i2c_WaitAck
00005c  b100              CBZ      r0,|L5.96|
;;;430    		{
;;;431    			goto cmd_fail;	/* EEPROM器件无应答 */
00005e  e007              B        |L5.112|
                  |L5.96|
;;;432    		}
;;;433    
;;;434    
;;;435    	
;;;436    	/* 命令执行成功，发送I2C总线停止信号 */
;;;437    	printf("写入成功");
000060  a005              ADR      r0,|L5.120|
000062  f7fffffe          BL       __2printf
;;;438    	i2c_Stop();
000066  f7fffffe          BL       i2c_Stop
;;;439    	return 1;
00006a  2001              MOVS     r0,#1
                  |L5.108|
;;;440    
;;;441    cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
;;;442    	/* 发送I2C总线停止信号 */
;;;443    	i2c_Stop();
;;;444    	return 0;
;;;445    }
00006c  e8bd81f0          POP      {r4-r8,pc}
                  |L5.112|
000070  f7fffffe          BL       i2c_Stop
000074  2000              MOVS     r0,#0                 ;444
000076  e7f9              B        |L5.108|
;;;446    
                          ENDP

                  |L5.120|
000078  d0b4c8eb          DCB      208,180,200,235,179,201,185,166,0
00007c  b3c9b9a6
000080  00      
000081  00                DCB      0
000082  00                DCB      0
000083  00                DCB      0

                          AREA ||i.i2c_Ack||, CODE, READONLY, ALIGN=2

                  i2c_Ack PROC
;;;189    */
;;;190    void i2c_Ack(void)
000000  b510              PUSH     {r4,lr}
;;;191    {
;;;192    	EEPROM_I2C_SDA_0();	/* CPU驱动SDA = 0 */
000002  2080              MOVS     r0,#0x80
000004  4909              LDR      r1,|L6.44|
000006  6008              STR      r0,[r1,#0]
;;;193    	i2c_Delay();
000008  f7fffffe          BL       i2c_Delay
;;;194    	EEPROM_I2C_SCL_1();	/* CPU产生1个时钟 */
00000c  2040              MOVS     r0,#0x40
00000e  4907              LDR      r1,|L6.44|
000010  1f09              SUBS     r1,r1,#4
000012  6008              STR      r0,[r1,#0]
;;;195    	i2c_Delay();
000014  f7fffffe          BL       i2c_Delay
;;;196    	EEPROM_I2C_SCL_0();
000018  2040              MOVS     r0,#0x40
00001a  4904              LDR      r1,|L6.44|
00001c  6008              STR      r0,[r1,#0]
;;;197    	i2c_Delay();
00001e  f7fffffe          BL       i2c_Delay
;;;198    	EEPROM_I2C_SDA_1();	/* CPU释放SDA总线 */
000022  2080              MOVS     r0,#0x80
000024  4901              LDR      r1,|L6.44|
000026  1f09              SUBS     r1,r1,#4
000028  6008              STR      r0,[r1,#0]
;;;199    }
00002a  bd10              POP      {r4,pc}
;;;200    
                          ENDP

                  |L6.44|
                          DCD      0x40010c14

                          AREA ||i.i2c_CfgGpio||, CODE, READONLY, ALIGN=2

                  i2c_CfgGpio PROC
;;;226    */
;;;227     void i2c_CfgGpio(void)
000000  b508              PUSH     {r3,lr}
;;;228    {
;;;229    	GPIO_InitTypeDef GPIO_InitStructure;
;;;230    
;;;231    	RCC_APB2PeriphClockCmd(EEPROM_RCC_I2C_PORT, ENABLE);	/* 打开GPIO时钟 */
000002  2101              MOVS     r1,#1
000004  2008              MOVS     r0,#8
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;232    
;;;233    	GPIO_InitStructure.GPIO_Pin = EEPROM_I2C_SCL_PIN | EEPROM_I2C_SDA_PIN;
00000a  20c0              MOVS     r0,#0xc0
00000c  f8ad0000          STRH     r0,[sp,#0]
;;;234    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000010  2003              MOVS     r0,#3
000012  f88d0002          STRB     r0,[sp,#2]
;;;235    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;  	/* 开漏输出 */
000016  2014              MOVS     r0,#0x14
000018  f88d0003          STRB     r0,[sp,#3]
;;;236    	GPIO_Init(EEPROM_GPIO_PORT_I2C, &GPIO_InitStructure);
00001c  4669              MOV      r1,sp
00001e  4803              LDR      r0,|L7.44|
000020  f7fffffe          BL       GPIO_Init
;;;237    
;;;238    	/* 给一个停止信号, 复位I2C总线上的所有设备到待机模式 */
;;;239    	i2c_Stop();
000024  f7fffffe          BL       i2c_Stop
;;;240    }
000028  bd08              POP      {r3,pc}
;;;241    
                          ENDP

00002a  0000              DCW      0x0000
                  |L7.44|
                          DCD      0x40010c00

                          AREA ||i.i2c_CheckDevice||, CODE, READONLY, ALIGN=1

                  i2c_CheckDevice PROC
;;;249    */
;;;250    uint8_t i2c_CheckDevice(uint8_t _Address)
000000  b570              PUSH     {r4-r6,lr}
;;;251    {
000002  4604              MOV      r4,r0
;;;252    	uint8_t ucAck;
;;;253    
;;;254    
;;;255    	
;;;256    	i2c_Start();		/* 发送启动信号 */
000004  f7fffffe          BL       i2c_Start
;;;257    
;;;258    	/* 发送设备地址+读写控制bit（0 = w， 1 = r) bit7 先传 */
;;;259    	i2c_SendByte(_Address | EEPROM_I2C_WR);
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       i2c_SendByte
;;;260    	ucAck = i2c_WaitAck();	/* 检测设备的ACK应答 */
00000e  f7fffffe          BL       i2c_WaitAck
000012  4605              MOV      r5,r0
;;;261    
;;;262    	i2c_Stop();			/* 发送停止信号 */
000014  f7fffffe          BL       i2c_Stop
;;;263    
;;;264    	return ucAck;
000018  4628              MOV      r0,r5
;;;265    }
00001a  bd70              POP      {r4-r6,pc}
;;;266    
                          ENDP


                          AREA ||i.i2c_Delay||, CODE, READONLY, ALIGN=1

                  i2c_Delay PROC
;;;34     */
;;;35     static void i2c_Delay(void)
000000  2000              MOVS     r0,#0
;;;36     {
;;;37     	uint8_t i;
;;;38     
;;;39     	/*　
;;;40     	 	下面的时间是通过逻辑分析仪测试得到的。
;;;41         工作条件：CPU主频72MHz ，MDK编译环境，1级优化
;;;42       
;;;43     		循环次数为10时，SCL频率 = 205KHz 
;;;44     		循环次数为7时，SCL频率 = 347KHz， SCL高电平时间1.5us，SCL低电平时间2.87us 
;;;45     	 	循环次数为5时，SCL频率 = 421KHz， SCL高电平时间1.25us，SCL低电平时间2.375us 
;;;46     	*/
;;;47     	for (i = 0; i < 10; i++);
000002  e001              B        |L9.8|
                  |L9.4|
000004  1c41              ADDS     r1,r0,#1
000006  b2c8              UXTB     r0,r1
                  |L9.8|
000008  280a              CMP      r0,#0xa
00000a  dbfb              BLT      |L9.4|
;;;48     }
00000c  4770              BX       lr
;;;49     
                          ENDP


                          AREA ||i.i2c_NAck||, CODE, READONLY, ALIGN=2

                  i2c_NAck PROC
;;;208    */
;;;209    void i2c_NAck(void)
000000  b510              PUSH     {r4,lr}
;;;210    {
;;;211    	EEPROM_I2C_SDA_1();	/* CPU驱动SDA = 1 */
000002  2080              MOVS     r0,#0x80
000004  4907              LDR      r1,|L10.36|
000006  6008              STR      r0,[r1,#0]
;;;212    	i2c_Delay();
000008  f7fffffe          BL       i2c_Delay
;;;213    	EEPROM_I2C_SCL_1();	/* CPU产生1个时钟 */
00000c  2040              MOVS     r0,#0x40
00000e  4905              LDR      r1,|L10.36|
000010  6008              STR      r0,[r1,#0]
;;;214    	i2c_Delay();
000012  f7fffffe          BL       i2c_Delay
;;;215    	EEPROM_I2C_SCL_0();
000016  2040              MOVS     r0,#0x40
000018  4902              LDR      r1,|L10.36|
00001a  1d09              ADDS     r1,r1,#4
00001c  6008              STR      r0,[r1,#0]
;;;216    	i2c_Delay();	
00001e  f7fffffe          BL       i2c_Delay
;;;217    }
000022  bd10              POP      {r4,pc}
;;;218    
                          ENDP

                  |L10.36|
                          DCD      0x40010c10

                          AREA ||i.i2c_ReadByte||, CODE, READONLY, ALIGN=2

                  i2c_ReadByte PROC
;;;130    */
;;;131    uint8_t i2c_ReadByte(void)
000000  b570              PUSH     {r4-r6,lr}
;;;132    {
;;;133    	uint8_t i;
;;;134    	uint8_t value;
;;;135    
;;;136    	/* 读到第1个bit为数据的bit7 */
;;;137    	value = 0;
000002  2400              MOVS     r4,#0
;;;138    	for (i = 0; i < 8; i++)
000004  2500              MOVS     r5,#0
000006  e016              B        |L11.54|
                  |L11.8|
;;;139    	{
;;;140    		value <<= 1;
000008  0660              LSLS     r0,r4,#25
00000a  0e04              LSRS     r4,r0,#24
;;;141    		EEPROM_I2C_SCL_1();
00000c  2040              MOVS     r0,#0x40
00000e  490c              LDR      r1,|L11.64|
000010  6008              STR      r0,[r1,#0]
;;;142    		i2c_Delay();
000012  f7fffffe          BL       i2c_Delay
;;;143    		if (EEPROM_I2C_SDA_READ())
000016  480a              LDR      r0,|L11.64|
000018  3808              SUBS     r0,r0,#8
00001a  6800              LDR      r0,[r0,#0]
00001c  f0000080          AND      r0,r0,#0x80
000020  b108              CBZ      r0,|L11.38|
;;;144    		{
;;;145    			value++;
000022  1c60              ADDS     r0,r4,#1
000024  b2c4              UXTB     r4,r0
                  |L11.38|
;;;146    		}
;;;147    		EEPROM_I2C_SCL_0();
000026  2040              MOVS     r0,#0x40
000028  4905              LDR      r1,|L11.64|
00002a  1d09              ADDS     r1,r1,#4
00002c  6008              STR      r0,[r1,#0]
;;;148    		i2c_Delay();
00002e  f7fffffe          BL       i2c_Delay
000032  1c68              ADDS     r0,r5,#1              ;138
000034  b2c5              UXTB     r5,r0                 ;138
                  |L11.54|
000036  2d08              CMP      r5,#8                 ;138
000038  dbe6              BLT      |L11.8|
;;;149    	}
;;;150    	return value;
00003a  4620              MOV      r0,r4
;;;151    }
00003c  bd70              POP      {r4-r6,pc}
;;;152    
                          ENDP

00003e  0000              DCW      0x0000
                  |L11.64|
                          DCD      0x40010c10

                          AREA ||i.i2c_SendByte||, CODE, READONLY, ALIGN=2

                  i2c_SendByte PROC
;;;94     */
;;;95     void i2c_SendByte(uint8_t _ucByte)
000000  b570              PUSH     {r4-r6,lr}
;;;96     {
000002  4604              MOV      r4,r0
;;;97     	uint8_t i;
;;;98     
;;;99     	/* 先发送字节的高位bit7 */
;;;100    	for (i = 0; i < 8; i++)
000004  2500              MOVS     r5,#0
000006  e020              B        |L12.74|
                  |L12.8|
;;;101    	{		
;;;102    		if (_ucByte & 0x80)
000008  f0040080          AND      r0,r4,#0x80
00000c  b118              CBZ      r0,|L12.22|
;;;103    		{
;;;104    			EEPROM_I2C_SDA_1();
00000e  2080              MOVS     r0,#0x80
000010  490f              LDR      r1,|L12.80|
000012  6008              STR      r0,[r1,#0]
000014  e003              B        |L12.30|
                  |L12.22|
;;;105    		}
;;;106    		else
;;;107    		{
;;;108    			EEPROM_I2C_SDA_0();
000016  2080              MOVS     r0,#0x80
000018  490d              LDR      r1,|L12.80|
00001a  1d09              ADDS     r1,r1,#4
00001c  6008              STR      r0,[r1,#0]
                  |L12.30|
;;;109    		}
;;;110    		i2c_Delay();
00001e  f7fffffe          BL       i2c_Delay
;;;111    		EEPROM_I2C_SCL_1();
000022  2040              MOVS     r0,#0x40
000024  490a              LDR      r1,|L12.80|
000026  6008              STR      r0,[r1,#0]
;;;112    		i2c_Delay();	
000028  f7fffffe          BL       i2c_Delay
;;;113    		EEPROM_I2C_SCL_0();
00002c  2040              MOVS     r0,#0x40
00002e  4908              LDR      r1,|L12.80|
000030  1d09              ADDS     r1,r1,#4
000032  6008              STR      r0,[r1,#0]
;;;114    		if (i == 7)
000034  2d07              CMP      r5,#7
000036  d102              BNE      |L12.62|
;;;115    		{
;;;116    			 EEPROM_I2C_SDA_1(); // 释放总线
000038  2080              MOVS     r0,#0x80
00003a  1f09              SUBS     r1,r1,#4
00003c  6008              STR      r0,[r1,#0]
                  |L12.62|
;;;117    		}
;;;118    		_ucByte <<= 1;	/* 左移一个bit */
00003e  0660              LSLS     r0,r4,#25
000040  0e04              LSRS     r4,r0,#24
;;;119    		i2c_Delay();
000042  f7fffffe          BL       i2c_Delay
000046  1c68              ADDS     r0,r5,#1              ;100
000048  b2c5              UXTB     r5,r0                 ;100
                  |L12.74|
00004a  2d08              CMP      r5,#8                 ;100
00004c  dbdc              BLT      |L12.8|
;;;120    	}
;;;121    }
00004e  bd70              POP      {r4-r6,pc}
;;;122    
                          ENDP

                  |L12.80|
                          DCD      0x40010c10

                          AREA ||i.i2c_Start||, CODE, READONLY, ALIGN=2

                  i2c_Start PROC
;;;57     */
;;;58     void i2c_Start(void)
000000  b510              PUSH     {r4,lr}
;;;59     {
;;;60     	/* 当SCL高电平时，SDA出现一个下跳沿表示I2C总线启动信号 */
;;;61     	EEPROM_I2C_SDA_1();
000002  2080              MOVS     r0,#0x80
000004  4909              LDR      r1,|L13.44|
000006  6008              STR      r0,[r1,#0]
;;;62     	EEPROM_I2C_SCL_1();
000008  2040              MOVS     r0,#0x40
00000a  6008              STR      r0,[r1,#0]
;;;63     	i2c_Delay();
00000c  f7fffffe          BL       i2c_Delay
;;;64     	EEPROM_I2C_SDA_0();
000010  2080              MOVS     r0,#0x80
000012  4906              LDR      r1,|L13.44|
000014  1d09              ADDS     r1,r1,#4
000016  6008              STR      r0,[r1,#0]
;;;65     	i2c_Delay();
000018  f7fffffe          BL       i2c_Delay
;;;66     	EEPROM_I2C_SCL_0();
00001c  2040              MOVS     r0,#0x40
00001e  4903              LDR      r1,|L13.44|
000020  1d09              ADDS     r1,r1,#4
000022  6008              STR      r0,[r1,#0]
;;;67     	i2c_Delay();
000024  f7fffffe          BL       i2c_Delay
;;;68     }
000028  bd10              POP      {r4,pc}
;;;69     
                          ENDP

00002a  0000              DCW      0x0000
                  |L13.44|
                          DCD      0x40010c10

                          AREA ||i.i2c_Stop||, CODE, READONLY, ALIGN=2

                  i2c_Stop PROC
;;;77     */
;;;78     void i2c_Stop(void)
000000  b510              PUSH     {r4,lr}
;;;79     {
;;;80     	/* 当SCL高电平时，SDA出现一个上跳沿表示I2C总线停止信号 */
;;;81     	EEPROM_I2C_SDA_0();
000002  2080              MOVS     r0,#0x80
000004  4905              LDR      r1,|L14.28|
000006  6008              STR      r0,[r1,#0]
;;;82     	EEPROM_I2C_SCL_1();
000008  2040              MOVS     r0,#0x40
00000a  1f09              SUBS     r1,r1,#4
00000c  6008              STR      r0,[r1,#0]
;;;83     	i2c_Delay();
00000e  f7fffffe          BL       i2c_Delay
;;;84     	EEPROM_I2C_SDA_1();
000012  2080              MOVS     r0,#0x80
000014  4901              LDR      r1,|L14.28|
000016  1f09              SUBS     r1,r1,#4
000018  6008              STR      r0,[r1,#0]
;;;85     }
00001a  bd10              POP      {r4,pc}
;;;86     
                          ENDP

                  |L14.28|
                          DCD      0x40010c14

                          AREA ||i.i2c_WaitAck||, CODE, READONLY, ALIGN=2

                  i2c_WaitAck PROC
;;;160    */
;;;161    uint8_t i2c_WaitAck(void)
000000  b510              PUSH     {r4,lr}
;;;162    {
;;;163    	uint8_t re;
;;;164    
;;;165    	EEPROM_I2C_SDA_1();	/* CPU释放SDA总线 */
000002  2080              MOVS     r0,#0x80
000004  490c              LDR      r1,|L15.56|
000006  6008              STR      r0,[r1,#0]
;;;166    	i2c_Delay();
000008  f7fffffe          BL       i2c_Delay
;;;167    	EEPROM_I2C_SCL_1();	/* CPU驱动SCL = 1, 此时器件会返回ACK应答 */
00000c  2040              MOVS     r0,#0x40
00000e  490a              LDR      r1,|L15.56|
000010  6008              STR      r0,[r1,#0]
;;;168    	i2c_Delay();
000012  f7fffffe          BL       i2c_Delay
;;;169    	if (EEPROM_I2C_SDA_READ())	/* CPU读取SDA口线状态 */
000016  4808              LDR      r0,|L15.56|
000018  3808              SUBS     r0,r0,#8
00001a  6800              LDR      r0,[r0,#0]
00001c  f0000080          AND      r0,r0,#0x80
000020  b108              CBZ      r0,|L15.38|
;;;170    	{
;;;171    		re = 1;
000022  2401              MOVS     r4,#1
000024  e000              B        |L15.40|
                  |L15.38|
;;;172    	}
;;;173    	else
;;;174    	{
;;;175    		re = 0;
000026  2400              MOVS     r4,#0
                  |L15.40|
;;;176    	}
;;;177    	EEPROM_I2C_SCL_0();
000028  2040              MOVS     r0,#0x40
00002a  4903              LDR      r1,|L15.56|
00002c  1d09              ADDS     r1,r1,#4
00002e  6008              STR      r0,[r1,#0]
;;;178    	i2c_Delay();
000030  f7fffffe          BL       i2c_Delay
;;;179    	return re;
000034  4620              MOV      r0,r4
;;;180    }
000036  bd10              POP      {r4,pc}
;;;181    
                          ENDP

                  |L15.56|
                          DCD      0x40010c10
