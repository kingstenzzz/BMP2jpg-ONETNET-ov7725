; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\diskio.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\diskio.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS -I..\..\User -I..\..\Libraries\FWlib\inc -I..\..\User\FATFS\option -I..\..\User\FATFS -I..\..\User\delay -I..\..\User\onenet\inc -I..\..\User\device\inc -I..\..\User\EDP -I..\..\User\onenet\inc -I..\..\User\hwtimer -I..\..\User\JPEGENCODE -I..\..\User\MALLOC -I..\..\User\dht11 -I..\..\User\flame -I..\..\User\warning -I..\..\User\beep -I..\..\User\adc -I..\..\User\IIC -I..\..\Freee-RTOS\include -I..\..\Freee-RTOS\portable\RVDS\ARM_CM3 -I..\..\User\IWDG -I..\..\User\light_moto -I..\..\User\M8266WIFI -I.\RTE\_____ -IF:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -IF:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=525 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\..\output\diskio.crf ..\..\User\FATFS\diskio.c]
                          THUMB

                          AREA ||i.disk_initialize||, CODE, READONLY, ALIGN=1

                  disk_initialize PROC
;;;45     /*-----------------------------------------------------------------------*/
;;;46     DSTATUS disk_initialize (
000000  b570              PUSH     {r4-r6,lr}
;;;47     	BYTE pdrv				/* 物理编号 */
;;;48     )
;;;49     {
000002  4604              MOV      r4,r0
;;;50     	DSTATUS status = STA_NOINIT;	
000004  2501              MOVS     r5,#1
;;;51     	switch (pdrv) {
000006  b114              CBZ      r4,|L1.14|
000008  2c01              CMP      r4,#1
00000a  d109              BNE      |L1.32|
00000c  e007              B        |L1.30|
                  |L1.14|
;;;52     		case ATA:	         /* SD CARD */
;;;53     			if(SD_Init()==SD_OK)
00000e  f7fffffe          BL       SD_Init
000012  b910              CBNZ     r0,|L1.26|
;;;54     			{
;;;55     				status &= ~STA_NOINIT;
000014  f0250501          BIC      r5,r5,#1
000018  e000              B        |L1.28|
                  |L1.26|
;;;56     			}
;;;57     			else 
;;;58     			{
;;;59     				status = STA_NOINIT;
00001a  2501              MOVS     r5,#1
                  |L1.28|
;;;60     			}
;;;61     		
;;;62     			break;
00001c  e002              B        |L1.36|
                  |L1.30|
;;;63         
;;;64     		case SPI_FLASH:    /* SPI Flash */ 
;;;65     			break;
00001e  e001              B        |L1.36|
                  |L1.32|
;;;66           
;;;67     		default:
;;;68     			status = STA_NOINIT;
000020  2501              MOVS     r5,#1
000022  bf00              NOP                            ;51
                  |L1.36|
000024  bf00              NOP                            ;62
;;;69     	}
;;;70     	return status;
000026  4628              MOV      r0,r5
;;;71     }
000028  bd70              POP      {r4-r6,pc}
;;;72     
                          ENDP


                          AREA ||i.disk_ioctl||, CODE, READONLY, ALIGN=2

                  disk_ioctl PROC
;;;200    #if _USE_IOCTL
;;;201    DRESULT disk_ioctl (
000000  b530              PUSH     {r4,r5,lr}
;;;202    	BYTE pdrv,		/* 物理编号 */
;;;203    	BYTE cmd,		  /* 控制指令 */
;;;204    	void *buff		/* 写入或者读取数据地址指针 */
;;;205    )
;;;206    {
000002  4603              MOV      r3,r0
;;;207    	DRESULT status = RES_PARERR;
000004  2004              MOVS     r0,#4
;;;208    	switch (pdrv) {
000006  b113              CBZ      r3,|L2.14|
000008  2b01              CMP      r3,#1
00000a  d11c              BNE      |L2.70|
00000c  e01a              B        |L2.68|
                  |L2.14|
;;;209    		case ATA:	/* SD CARD */
;;;210    			switch (cmd) 
00000e  b1a9              CBZ      r1,|L2.60|
000010  2901              CMP      r1,#1
000012  d00b              BEQ      |L2.44|
000014  2902              CMP      r1,#2
000016  d002              BEQ      |L2.30|
000018  2903              CMP      r1,#3
00001a  d110              BNE      |L2.62|
00001c  e003              B        |L2.38|
                  |L2.30|
;;;211    			{
;;;212    				// Get R/W sector size (WORD) 
;;;213    				case GET_SECTOR_SIZE :    
;;;214    					*(WORD * )buff = SD_BLOCKSIZE;
00001e  f44f7400          MOV      r4,#0x200
000022  8014              STRH     r4,[r2,#0]
;;;215    				break;
000024  e00b              B        |L2.62|
                  |L2.38|
;;;216    				// Get erase block size in unit of sector (DWORD)
;;;217    				case GET_BLOCK_SIZE :      
;;;218    					*(DWORD * )buff = 1;
000026  2401              MOVS     r4,#1
000028  6014              STR      r4,[r2,#0]
;;;219    				break;
00002a  e008              B        |L2.62|
                  |L2.44|
;;;220    
;;;221    				case GET_SECTOR_COUNT:
;;;222    					*(DWORD * )buff = SDCardInfo.CardCapacity/SDCardInfo.CardBlockSize;
00002c  4c08              LDR      r4,|L2.80|
00002e  6c64              LDR      r4,[r4,#0x44]  ; SDCardInfo
000030  4d07              LDR      r5,|L2.80|
000032  6cad              LDR      r5,[r5,#0x48]  ; SDCardInfo
000034  fbb4f4f5          UDIV     r4,r4,r5
000038  6014              STR      r4,[r2,#0]
;;;223    					break;
00003a  e000              B        |L2.62|
                  |L2.60|
;;;224    				case CTRL_SYNC :
;;;225    				break;
00003c  bf00              NOP      
                  |L2.62|
00003e  bf00              NOP                            ;215
;;;226    			}
;;;227    			status = RES_OK;
000040  2000              MOVS     r0,#0
;;;228    			break;
000042  e002              B        |L2.74|
                  |L2.68|
;;;229        
;;;230    		case SPI_FLASH:		      
;;;231    		break;
000044  e001              B        |L2.74|
                  |L2.70|
;;;232        
;;;233    		default:
;;;234    			status = RES_PARERR;
000046  2004              MOVS     r0,#4
000048  bf00              NOP                            ;208
                  |L2.74|
00004a  bf00              NOP                            ;228
;;;235    	}
;;;236    	return status;
;;;237    }
00004c  bd30              POP      {r4,r5,pc}
;;;238    #endif
                          ENDP

00004e  0000              DCW      0x0000
                  |L2.80|
                          DCD      SDCardInfo

                          AREA ||i.disk_read||, CODE, READONLY, ALIGN=1

                  disk_read PROC
;;;76     /*-----------------------------------------------------------------------*/
;;;77     DRESULT disk_read (
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;78     	BYTE pdrv,		/* 设备物理编号(0..) */
;;;79     	BYTE *buff,		/* 数据缓存区 */
;;;80     	DWORD sector,	/* 扇区首地址 */
;;;81     	UINT count		/* 扇区个数(1..128) */
;;;82     )
;;;83     {
000004  f5ad7d00          SUB      sp,sp,#0x200
000008  4606              MOV      r6,r0
00000a  460c              MOV      r4,r1
00000c  4615              MOV      r5,r2
00000e  461f              MOV      r7,r3
;;;84     	DRESULT status = RES_PARERR;
000010  f04f0a04          MOV      r10,#4
;;;85     	SD_Error SD_state = SD_OK;
000014  f04f0800          MOV      r8,#0
;;;86     	
;;;87     	switch (pdrv) {
000018  b116              CBZ      r6,|L3.32|
00001a  2e01              CMP      r6,#1
00001c  d141              BNE      |L3.162|
00001e  e03f              B        |L3.160|
                  |L3.32|
;;;88     		case ATA:	/* SD CARD */						
;;;89     		  if((DWORD)buff&3)
000020  f0040003          AND      r0,r4,#3
000024  b300              CBZ      r0,|L3.104|
;;;90     			{
;;;91     				DRESULT res = RES_OK;
000026  f04f0900          MOV      r9,#0
;;;92     				DWORD scratch[SD_BLOCKSIZE / 4];
;;;93     
;;;94     				while (count--) 
00002a  e013              B        |L3.84|
                  |L3.44|
;;;95     				{
;;;96     					res = disk_read(ATA,(void *)scratch, sector++, 1);
00002c  462a              MOV      r2,r5
00002e  1c6d              ADDS     r5,r5,#1
000030  2301              MOVS     r3,#1
000032  4669              MOV      r1,sp
000034  2000              MOVS     r0,#0
000036  f7fffffe          BL       disk_read
00003a  4681              MOV      r9,r0
;;;97     
;;;98     					if (res != RES_OK) 
00003c  f1b90f00          CMP      r9,#0
000040  d000              BEQ      |L3.68|
;;;99     					{
;;;100    						break;
000042  e00b              B        |L3.92|
                  |L3.68|
;;;101    					}
;;;102    					memcpy(buff, scratch, SD_BLOCKSIZE);
000044  f44f7200          MOV      r2,#0x200
000048  4669              MOV      r1,sp
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       __aeabi_memcpy
;;;103    					buff += SD_BLOCKSIZE;
000050  f5047400          ADD      r4,r4,#0x200
                  |L3.84|
000054  1e38              SUBS     r0,r7,#0              ;94
000056  f1a70701          SUB      r7,r7,#1              ;94
00005a  d1e7              BNE      |L3.44|
                  |L3.92|
00005c  bf00              NOP                            ;100
;;;104    		    }
;;;105    		    return res;
00005e  4648              MOV      r0,r9
                  |L3.96|
;;;106    			}
;;;107    			
;;;108    			SD_state=SD_ReadMultiBlocks(buff,sector*SD_BLOCKSIZE,SD_BLOCKSIZE,count);
;;;109    		  if(SD_state==SD_OK)
;;;110    			{
;;;111    				/* Check if the Transfer is finished */
;;;112    				SD_state=SD_WaitReadOperation();
;;;113    				while(SD_GetStatus() != SD_TRANSFER_OK);
;;;114    			}
;;;115    			if(SD_state!=SD_OK)
;;;116    				status = RES_PARERR;
;;;117    		  else
;;;118    			  status = RES_OK;	
;;;119    			break;   
;;;120    			
;;;121    		case SPI_FLASH:
;;;122    		break;
;;;123        
;;;124    		default:
;;;125    			status = RES_PARERR;
;;;126    	}
;;;127    	return status;
;;;128    }
000060  f50d7d00          ADD      sp,sp,#0x200
000064  e8bd87f0          POP      {r4-r10,pc}
                  |L3.104|
000068  0269              LSLS     r1,r5,#9              ;108
00006a  463b              MOV      r3,r7                 ;108
00006c  f44f7200          MOV      r2,#0x200             ;108
000070  4620              MOV      r0,r4                 ;108
000072  f7fffffe          BL       SD_ReadMultiBlocks
000076  4680              MOV      r8,r0                 ;108
000078  f1b80f00          CMP      r8,#0                 ;109
00007c  d107              BNE      |L3.142|
00007e  f7fffffe          BL       SD_WaitReadOperation
000082  4680              MOV      r8,r0                 ;112
000084  bf00              NOP                            ;113
                  |L3.134|
000086  f7fffffe          BL       SD_GetStatus
00008a  2800              CMP      r0,#0                 ;113
00008c  d1fb              BNE      |L3.134|
                  |L3.142|
00008e  f1b80f00          CMP      r8,#0                 ;115
000092  d002              BEQ      |L3.154|
000094  f04f0a04          MOV      r10,#4                ;116
000098  e001              B        |L3.158|
                  |L3.154|
00009a  f04f0a00          MOV      r10,#0                ;118
                  |L3.158|
00009e  e003              B        |L3.168|
                  |L3.160|
0000a0  e002              B        |L3.168|
                  |L3.162|
0000a2  f04f0a04          MOV      r10,#4                ;125
0000a6  bf00              NOP                            ;87
                  |L3.168|
0000a8  bf00              NOP                            ;119
0000aa  4650              MOV      r0,r10                ;127
0000ac  e7d8              B        |L3.96|
;;;129    
                          ENDP


                          AREA ||i.disk_status||, CODE, READONLY, ALIGN=1

                  disk_status PROC
;;;22     /*-----------------------------------------------------------------------*/
;;;23     DSTATUS disk_status (
000000  4601              MOV      r1,r0
;;;24     	BYTE pdrv		/* 物理编号 */
;;;25     )
;;;26     {
;;;27     	DSTATUS status = STA_NOINIT;
000002  2001              MOVS     r0,#1
;;;28     	
;;;29     	switch (pdrv) {
000004  b111              CBZ      r1,|L4.12|
000006  2901              CMP      r1,#1
000008  d104              BNE      |L4.20|
00000a  e002              B        |L4.18|
                  |L4.12|
;;;30     		case ATA:	/* SD CARD */
;;;31     			status &= ~STA_NOINIT;
00000c  f0200001          BIC      r0,r0,#1
;;;32     			break;
000010  e002              B        |L4.24|
                  |L4.18|
;;;33         
;;;34     		case SPI_FLASH:        /* SPI Flash */   
;;;35     			break;
000012  e001              B        |L4.24|
                  |L4.20|
;;;36     
;;;37     		default:
;;;38     			status = STA_NOINIT;
000014  2001              MOVS     r0,#1
000016  bf00              NOP                            ;29
                  |L4.24|
000018  bf00              NOP                            ;32
;;;39     	}
;;;40     	return status;
;;;41     }
00001a  4770              BX       lr
;;;42     
                          ENDP


                          AREA ||i.disk_write||, CODE, READONLY, ALIGN=1

                  disk_write PROC
;;;135    #if _USE_WRITE
;;;136    DRESULT disk_write (
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;137    	BYTE pdrv,			  /* 设备物理编号(0..) */
;;;138    	const BYTE *buff,	/* 欲写入数据的缓存区 */
;;;139    	DWORD sector,		  /* 扇区首地址 */
;;;140    	UINT count			  /* 扇区个数(1..128) */
;;;141    )
;;;142    {
000004  f5ad7d00          SUB      sp,sp,#0x200
000008  4607              MOV      r7,r0
00000a  460c              MOV      r4,r1
00000c  4615              MOV      r5,r2
00000e  461e              MOV      r6,r3
;;;143    	DRESULT status = RES_PARERR;
000010  f04f0a04          MOV      r10,#4
;;;144    	SD_Error SD_state = SD_OK;
000014  f04f0800          MOV      r8,#0
;;;145    	
;;;146    	if (!count) {
000018  b926              CBNZ     r6,|L5.36|
;;;147    		return RES_PARERR;		/* Check parameter */
00001a  2004              MOVS     r0,#4
                  |L5.28|
;;;148    	}
;;;149    
;;;150    	switch (pdrv) {
;;;151    		case ATA:	/* SD CARD */  
;;;152    			if((DWORD)buff&3)
;;;153    			{
;;;154    				DRESULT res = RES_OK;
;;;155    				DWORD scratch[SD_BLOCKSIZE / 4];
;;;156    
;;;157    				while (count--) 
;;;158    				{
;;;159    					memcpy( scratch,buff,SD_BLOCKSIZE);
;;;160    					res = disk_write(ATA,(void *)scratch, sector++, 1);
;;;161    					if (res != RES_OK) 
;;;162    					{
;;;163    						break;
;;;164    					}					
;;;165    					buff += SD_BLOCKSIZE;
;;;166    		    }
;;;167    		    return res;
;;;168    			}		
;;;169    		
;;;170    			SD_state=SD_WriteMultiBlocks((uint8_t *)buff,sector*SD_BLOCKSIZE,SD_BLOCKSIZE,count);
;;;171    			if(SD_state==SD_OK)
;;;172    			{
;;;173    				/* Check if the Transfer is finished */
;;;174    				SD_state=SD_WaitWriteOperation();
;;;175    
;;;176    				/* Wait until end of DMA transfer */
;;;177    				while(SD_GetStatus() != SD_TRANSFER_OK);			
;;;178    			}
;;;179    			if(SD_state!=SD_OK)
;;;180    				status = RES_PARERR;
;;;181    		  else
;;;182    			  status = RES_OK;	
;;;183    		break;
;;;184    
;;;185    		case SPI_FLASH:
;;;186    		break;
;;;187        
;;;188    		default:
;;;189    			status = RES_PARERR;
;;;190    	}
;;;191    	return status;
;;;192    }
00001c  f50d7d00          ADD      sp,sp,#0x200
000020  e8bd87f0          POP      {r4-r10,pc}
                  |L5.36|
000024  b117              CBZ      r7,|L5.44|
000026  2f01              CMP      r7,#1                 ;150
000028  d13e              BNE      |L5.168|
00002a  e03c              B        |L5.166|
                  |L5.44|
00002c  f0040003          AND      r0,r4,#3              ;152
000030  b1e8              CBZ      r0,|L5.110|
000032  f04f0900          MOV      r9,#0                 ;154
000036  e013              B        |L5.96|
                  |L5.56|
000038  f44f7200          MOV      r2,#0x200             ;159
00003c  4621              MOV      r1,r4                 ;159
00003e  4668              MOV      r0,sp                 ;159
000040  f7fffffe          BL       __aeabi_memcpy
000044  462a              MOV      r2,r5                 ;160
000046  1c6d              ADDS     r5,r5,#1              ;160
000048  2301              MOVS     r3,#1                 ;160
00004a  4669              MOV      r1,sp                 ;160
00004c  2000              MOVS     r0,#0                 ;160
00004e  f7fffffe          BL       disk_write
000052  4681              MOV      r9,r0                 ;160
000054  f1b90f00          CMP      r9,#0                 ;161
000058  d000              BEQ      |L5.92|
00005a  e005              B        |L5.104|
                  |L5.92|
00005c  f5047400          ADD      r4,r4,#0x200          ;165
                  |L5.96|
000060  1e30              SUBS     r0,r6,#0              ;157
000062  f1a60601          SUB      r6,r6,#1              ;157
000066  d1e7              BNE      |L5.56|
                  |L5.104|
000068  bf00              NOP                            ;163
00006a  4648              MOV      r0,r9                 ;167
00006c  e7d6              B        |L5.28|
                  |L5.110|
00006e  0269              LSLS     r1,r5,#9              ;170
000070  4633              MOV      r3,r6                 ;170
000072  f44f7200          MOV      r2,#0x200             ;170
000076  4620              MOV      r0,r4                 ;170
000078  f7fffffe          BL       SD_WriteMultiBlocks
00007c  4680              MOV      r8,r0                 ;170
00007e  f1b80f00          CMP      r8,#0                 ;171
000082  d107              BNE      |L5.148|
000084  f7fffffe          BL       SD_WaitWriteOperation
000088  4680              MOV      r8,r0                 ;174
00008a  bf00              NOP                            ;177
                  |L5.140|
00008c  f7fffffe          BL       SD_GetStatus
000090  2800              CMP      r0,#0                 ;177
000092  d1fb              BNE      |L5.140|
                  |L5.148|
000094  f1b80f00          CMP      r8,#0                 ;179
000098  d002              BEQ      |L5.160|
00009a  f04f0a04          MOV      r10,#4                ;180
00009e  e001              B        |L5.164|
                  |L5.160|
0000a0  f04f0a00          MOV      r10,#0                ;182
                  |L5.164|
0000a4  e003              B        |L5.174|
                  |L5.166|
0000a6  e002              B        |L5.174|
                  |L5.168|
0000a8  f04f0a04          MOV      r10,#4                ;189
0000ac  bf00              NOP                            ;150
                  |L5.174|
0000ae  bf00              NOP                            ;183
0000b0  4650              MOV      r0,r10                ;191
0000b2  e7b3              B        |L5.28|
;;;193    #endif
                          ENDP


                          AREA ||i.get_fattime||, CODE, READONLY, ALIGN=2

                  get_fattime PROC
;;;240    							 
;;;241    __weak DWORD get_fattime(void) {
000000  4800              LDR      r0,|L6.4|
;;;242    	/* 返回当前时间戳 */
;;;243    	return	  ((DWORD)(2015 - 1980) << 25)	/* Year 2015 */
;;;244    			| ((DWORD)1 << 21)				/* Month 1 */
;;;245    			| ((DWORD)1 << 16)				/* Mday 1 */
;;;246    			| ((DWORD)0 << 11)				/* Hour 0 */
;;;247    			| ((DWORD)0 << 5)				  /* Min 0 */
;;;248    			| ((DWORD)0 >> 1);				/* Sec 0 */
;;;249    }
000002  4770              BX       lr
;;;250    
                          ENDP

                  |L6.4|
                          DCD      0x46210000
